<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Perst.NET</name>
    </assembly>
    <members>
        <member name="T:Perst.StorageListener">
            <summary>
            Listener of database events. Programmer should derive his own subclass and register
            it using Storage.setListener method.
            </summary>
        </member>
        <member name="M:Perst.StorageListener.DatabaseCorrupted">
            <summary>
            This metod is called during database open when database was not
            close normally and has to be recovered
            </summary>
        </member>
        <member name="M:Perst.StorageListener.RecoveryCompleted">
            <summary>
            This method is called after completion of recovery
            </summary>
        </member>
        <member name="M:Perst.StorageListener.OnObjectLoad(System.Object)">
            <summary>
            Method invoked by Perst affter object is loaded from the database 
            </summary>
            <param name="obj">loaded object</param>
                   
        </member>
        <member name="M:Perst.StorageListener.OnObjectStore(System.Object)">
            <summary>
            Method invoked by Perst before object is written to the database 
            </summary>
            <param name="obj">stored object</param>
                   
        </member>
        <member name="M:Perst.StorageListener.OnObjectDelete(System.Object)">
            <summary>
            Method invoked by Perst before object is deallocated
            </summary>
            <param name="obj">deallocated object</param>
                   
        </member>
        <member name="M:Perst.StorageListener.OnObjectAssignOid(System.Object)">
            <summary>
            Method invoked by Perst after object is assigned OID (becomes persisistent)
            </summary>
            <param name="obj">object which is made persistent</param>
                   
        </member>
        <member name="M:Perst.StorageListener.GcStarted">
            <summary>
            This method is called when garbage collection is  started (ether explicitly
            by invocation of Storage.gc() method, either implicitly  after allocation
            of some amount of memory)).
            </summary>
        </member>
        <member name="M:Perst.StorageListener.DeallocateObject(System.Type,System.Int32)">
             <summary>
             This method is called  when unreferenced object is deallocated from 
             database during garbage collection. It is possible to get instance of the object using
             <see cref="M:Perst.Storage.GetObjectByOid"/> method.
             </summary>
             <param name="cls">class of deallocated object</param>
             <param name="oid">object identifier of deallocated object</param>
            
        </member>
        <member name="M:Perst.StorageListener.GcCompleted(System.Int32)">
             <summary>
             This method is called when garbage collection is completed
             </summary>
             <param name="nDeallocatedObjects">number of deallocated objects</param>
            
        </member>
        <member name="M:Perst.StorageListener.ReplicationError(System.String)">
            <summary>
            Handle replication error 
            </summary>
            <param name="host">address of host replication to which is failed (null if error jappens at slave node)</param>
            <returns><b>true</b> if host should be reconnected and attempt to send data to it should be 
            repeated, <b>false</b> if no more attmpts to communicate with this host should be performed
            </returns>
        </member>
        <member name="M:Perst.StorageListener.JSQLRuntimeError(Perst.JSQLRuntimeException)">
            <summary> This method is called when runtime error happen during execution of JSQL query
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Perst.StorageListener.QueryExecution(System.Object,System.Int64,System.Boolean)" -->
        <member name="M:Perst.StorageListener.SequentialSearchPerformed(System.Object)">
             <summary> 
             Sequential search is performed for query execution
             </summary>
             <param name="query">executed query</param>
            
        </member>
        <member name="M:Perst.StorageListener.SortResultSetPerformed(System.Object)">
             <summary> 
             Sort of the selected result set is performed for query execution
             </summary>
             <param name="query">executed query</param>
            
        </member>
        <member name="M:Perst.StorageListener.IndexCreated(System.Type,System.String)">
             <summary> 
             Index is automaticaslly created by Database class when query is executed and autoIndices is anabled
             </summary> 
             <param name="table">table for which index is created</param>
             <param name="field">index key</param>
            
        </member>
        <member name="T:Perst.StorageError">
            <summary> Exception throw by storage implementation
            </summary>
        </member>
        <member name="P:Perst.StorageError.Code">
            <summary> Get exception error code (see definitions above)
            </summary>
        </member>
        <member name="P:Perst.StorageError.OriginalException">
            <summary> Get original exception if StorageError excepotion was thrown as the result 
            of catching some other exception within Storage implementation. 
            StorageError is used as wrapper of other exceptions to avoid cascade propagation
            of throws and try/catch constructions.
            </summary>
            <returns>original exception or <b>null</b> if there is no such exception
            
            </returns>
        </member>
        <member name="T:Perst.JSQLArithmeticException">
            <summary> Exception thown in case of incorect operands for integer operations
            </summary>
        </member>
        <member name="T:Perst.JSQLRuntimeException">
            <summary> Exception thown by JSQL at runtime which should be ignored and boolean expression caused this
            exption should be treated as false
            </summary>
        </member>
        <member name="M:Perst.JSQLRuntimeException.#ctor(System.String,System.Type,System.String)">
            <summary> Constructor of exception
            </summary>
            <param name="target">class of the target object in which field was not found
            </param>
            <param name="fieldName">name of the locate field
            
            </param>
        </member>
        <member name="P:Perst.JSQLRuntimeException.Target">
            <summary> Get class in which lookup was performed
            </summary>
        </member>
        <member name="P:Perst.JSQLRuntimeException.FieldName">
            <summary> Get name of the field
            </summary>
        </member>
        <member name="M:Perst.JSQLArithmeticException.#ctor(System.String)">
            <summary> Constructor of exception
            </summary>
        </member>
        <member name="T:Perst.PersistentCollection">
            <summary>
            Base class for all persistent collections
            </summary>
        </member>
        <member name="T:Perst.PersistentResource">
            <summary>Base class for persistent capable objects supporting locking
            </summary>
        </member>
        <member name="T:Perst.Persistent">
            <summary> Base class for all persistent capable objects
            </summary>
        </member>
        <member name="T:Perst.IPersistent">
            <summary> Interface of all persistent capable objects
            </summary>
        </member>
        <member name="T:Perst.ILoadable">
             <summary>
             Interface for classes which need onLoad callback to be invoked
             when Perst loads object from the storage
             </summary>
            
        </member>
        <member name="M:Perst.ILoadable.OnLoad">
             <summary>
             Method called by the database after loading of the object.
             It can be used to initialize transient fields of the object. 
             Default implementation of this method do nothing
             </summary>
            
        </member>
        <member name="T:Perst.IStoreable">
             <summary>
             Interface for classes which need onStore callback to be invoked
             when Perst storess object to the storage
             </summary>
            
        </member>
        <member name="M:Perst.IStoreable.OnStore">
             <summary>
             Method called by the database before storing of the object.
             It can be used to save or close transient fields of the object. 
             Default implementation of this method do nothing
             </summary>
            
        </member>
        <member name="M:Perst.IPersistent.Load">
            <summary> Load object from the database (if needed)
            </summary>
        </member>
        <member name="M:Perst.IPersistent.IsRaw">
            
            <summary> Check if object is stub and has to be loaded from the database
            </summary>
            <returns><b>true</b> if object has to be loaded from the database
            </returns>
        </member>
        <member name="M:Perst.IPersistent.IsPersistent">
            <summary> Check if object is persistent 
            </summary>
            <returns><b>true</b> if object has assigned OID
            
            </returns>
        </member>
        <member name="M:Perst.IPersistent.IsDeleted">
            <summary>  Check if object is deleted by GC from process memory
            </summary>
            <returns> <b>true</b> if object is deleted by GC
            </returns>
        </member>
        <member name="M:Perst.IPersistent.IsModified">
            <summary> Check if object was modified within current transaction
            </summary>
            <returns><b>true</b> if object is persistent and was modified within current transaction
            
            </returns>
        </member>
        <member name="M:Perst.IPersistent.MakePersistent(Perst.Storage)">
            <summary> Explicitely make object peristent. Usually objects are made persistent
            implicitlely using "persistency on reachability apporach", but this
            method allows to do it explicitly 
            </summary>
            <param name="storage">storage in which object should be stored 
            </param>
            <returns>OID assigned to the object</returns>
        </member>
        <member name="M:Perst.IPersistent.Store">
            <summary> Save object in the database
            </summary>
        </member>
        <member name="M:Perst.IPersistent.Modify">
            <summary>
            Mark object as modified. Object will be saved to the database during transaction commit.
            </summary>
        </member>
        <member name="M:Perst.IPersistent.Deallocate">
            <summary> Deallocate persistent object from the database
            </summary>
        </member>
        <member name="M:Perst.IPersistent.RecursiveLoading">
            <summary> Specified whether object should be automatically loaded when it is referenced
            by other loaded peristent object. Default implementation of this method
            returns <b>true</b> making all cluster of referenced objects loaded together. 
            To avoid main memory overflow you should stop recursive loading of all objects
            from the database to main memory by redefining this method in some classes and returing
            <b>false</b> in it. In this case object has to be loaded explicitely 
            using Persistent.load method.
            </summary>
            <returns><b>true</b> if object is automatically loaded
            
            </returns>
        </member>
        <member name="M:Perst.IPersistent.Invalidate">
            <summary>
            Invalidate object. Invalidated object has to be explicitly
            reloaded using load() method. Attempt to store invalidated object
            will cause StoraegError exception.
            </summary>
        </member>
        <member name="M:Perst.IPersistent.AssignOid(Perst.Storage,System.Int32,System.Boolean)">
            <summary>
            Method used to associate object with storage.
            This method is used by Storage class and you should not use it explicitly.
            </summary>
            <param name="storage">storage to be assigned to</param>
            <param name="oid">assigned OID</param>
            <param name="raw">if object is already loaded</param>
        </member>
        <member name="P:Perst.IPersistent.Oid">
            <summary> Get object identifier (OID)
            </summary>
        </member>
        <member name="P:Perst.IPersistent.Storage">
            <summary> Get storage in which this object is stored
            </summary>
        </member>
        <member name="T:Perst.IResource">
            <summary>
             Interface of object supporting locking
             </summary>
        </member>
        <member name="M:Perst.IResource.SharedLock">
            <summary>
            Lock persistent object in shared mode. Other threads will be able to set their
            shared locks on this objects, but not exclusive lock can be set until this lock is released.
            
            Upgrading of the lock is not possible (thread having read lock can not upgrade it to exclusive lock).
            It is done to prevent possible deadlocks caused by lock updates. 
            But locks are reentrant - so thread can request the same lock many times (and correspondent 
            number of unlocks is needed to release the lock).
            
            Locking the object doesn't prevent other threads from accessing the object - 
            it only has influence on <see cref="M:Perst.IResource.SharedLock"/> and <see cref="M:Perst.IResource.ExclusiveLock"/> methods.
            So programmer should set proper lock before accessing the object in multithreaded application.
            
            If object is concurrently accessed by several threads in read-only mode, then explicit locking
            of this object is not needed, because language API provides consistent retrieving of objects itself.
            
            Only persistent object (object which were assigned to the the storage either implicitly by
            saving some other persistent object referencing this object, either explicitly by 
            <see cref="M:Perst.Storage.MakePersistent"/> method.
            </summary>
        </member>
        <member name="M:Perst.IResource.ExclusiveLock">
             <summary>
             Lock persistent object in exclusive mode. Only one thread can lock object in exclusive mode at each
             moment of time. Shared or exclusive lock requests of other threads will be blocked until
             this lock is released.
             shared locks on this objects, but not exclusive lock can be set until this lock is released.
             
             This lock is reentrant, so thread owning the lock can successfully retrieve the lock many times
             (and correspondent number of unlocks is needed to release the lock).
             
             Locking the object doesn't prevent other threads from accessing the object - 
             it only has influence on <see cref="M:Perst.IResource.SharedLock"/> and <see cref="M:Perst.IResource.ExclusiveLock"/> methods.
             So programmer should set proper lock before accessing the object in multithreaded application.
            
             Only persistent object (object which were assigned to the the storage either implicitly by
             saving some other persistent object referencing this object, either explicitly by 
             <see cref="M:Perst.Storage.MakePersistent"/> method.
             </summary>
        </member>
        <member name="M:Perst.IResource.SharedLock(System.Int64)">
            <summary>
            Lock persistent object in shared mode. Other threads will be able to set their
            shared locks on this objects, but not exclusive lock can be set until this lock is released.
            
            Upgrading of the lock is not possible (thread having read lock can not upgrade it to exclusive lock).
            It is done to prevent possible deadlocks caused by lock updates. 
            But locks are reentrant - so thread can request the same lock many times (and correspondent 
            number of unlocks is needed to release the lock).
             
            Locking the object doesn't prevent other threads from accessing the object - 
            it only has influence on <see cref="M:Perst.IResource.SharedLock"/> and <see cref="M:Perst.IResource.ExclusiveLock"/> methods.
            So programmer should set proper lock before accessing the object in multithreaded application.
            
            If object is concurrently accessed by several threads in read-only mode, then explicit locking
            of this object is not needed, because language API provides consistent retrieving of objects itself.
            
            Only persistent object (object which were assigned to the the storage either implicitly by
            saving some other persistent object referencing this object, either explicitly by 
            <see cref="M:Perst.Storage.MakePersistent"/> method.
            </summary>
            <param name="timeout">timeout of operation in milliseconds. If timeout is 0 and
            lock can not be granted, the request will fail immediately. Otherwise the system will try
            to grant lock within specified amount of time.
            </param>
            <returns>
            <DL>
            <DT><b>true</b> if lock is successfully granted</DT>
            <DT><b>false</b> if lock can not be granted within specified time</DT> 
            </DL>
            </returns>
        </member>
        <member name="M:Perst.IResource.ExclusiveLock(System.Int64)">
             <summary>
             Lock persistent object in exclusive mode. Only one thread can lock object in exclusive mode at each
             moment of time. Shared or exclusive lock requests of other threads will be blocked until
             this lock is released.
             shared locks on this objects, but not exclusive lock can be set until this lock is released.
             
             This lock is reentrant, so thread owning the lock can successfully retrieve the lock many times
             (and correspondent number of unlocks is needed to release the lock).
             
             Locking the object doesn't prevent other threads from accessing the object - 
             it only has influence on <b>sharedLock</b> and <b>exclusiveLock</b> methods.
            So programmer should set proper lock before accessing the object in multithreaded application.
            
             Only persistent object (object which were assigned to the the storage either implicitly by
             saving some other persistent object referencing this object, either explicitly by 
             <b>Storage.makeObjectPersistent</b> method.   
             </summary>
             <param name="timeout">timeout of operation in milliseconds. If timeout is 0 and
             lock can not be granted, the request will fail immediately. Otherwise the system will try
             to grant lock within specified amount of time.
             </param>
             <returns>
             <DL>
             <DT><b>true</b> if lock is successfully granted</DT>
             <DT><b>false</b> if lock can not be granted within specified time</DT>
             </DL>
             </returns>
        </member>
        <member name="M:Perst.IResource.Unlock">
            <summary>
            Remove granted lock. If lock was requested several times by one thread, then correspondent number
            of unlocks is needed to release the lock.
            </summary>
        </member>
        <member name="M:Perst.IResource.Reset">
            <summary>
            Reset resource to original state.
            Wakrup all threads waiting for this resource.
            </summary>
        </member>
        <member name="T:Perst.ITable">
            <summary> Interface of selectable collection.
            Selectable collections allows to selct its memebers using JSQL query
            </summary>
        </member>
        <member name="M:Perst.ITable.Select(System.Type,System.String)">
            <summary> Select members of the collection using search predicate
            </summary>
            <param name="cls">class of index members
            </param>
            <param name="predicate">JSQL condition
            </param>
            <returns> iterator through members of the collection matching search condition
            </returns>
        </member>
        <member name="M:Perst.ITable.Clear">
            <summary> Remove all objects from the index
            </summary>
        </member>
        <member name="M:Perst.ITable.DeallocateMembers">
            <summary>
            Remove all objects from the index and deallocate them.
            This method is equivalent to th following peace of code:
            { foreach (IPersistent o in this) o.Deallocate(); Clear(); }
            Please notice that this method doesn't check if there are some other references to the deallocated objects.
            If deallocated object is included in some other index or is referenced from some other objects, then after deallocation
            there will be dangling references and dereferencing them can cause unpredictable behavior of the program.
            </summary>
        </member>
        <member name="T:Perst.IPersistentList">
            <summary>
             Interface for ordered collection (sequence). 
             The user can access elements by their integer index (position in
             the list), and search for elements in the list.
             </summary>
        </member>
        <member name="M:Perst.IPersistentList.Clear">
            <summary> Remove all objects from the index
            </summary>
        </member>
        <member name="M:Perst.IPersistentList.ToArray">
            <summary> Get relation members as array of objects
            </summary>
            <returns>created array</returns>
        </member>
        <member name="M:Perst.IPersistentList.ToArray(System.Type)">
            <summary> Get relation members as array with specifed element type
            </summary>
            <param name="elemType">element type of created array</param>
            <returns>created array</returns>
        </member>
        <member name="M:Perst.IPersistentList.GetEnumerator(System.Int32)">
            <summary>
            Get bidirectional enumerator started with specified current position
            </summary>
            <param name="start">position of the first element. 
            After creation of this enumerator <see cref="P:System.IO.IEnumerator.Current"/> property points to the list 
            element with index <b>start</b> (if any), following <see cref="M:System.IO.IEnumerator.MoveNext"/> moves 
            enumerator current position to the element with index <b>star+1</b> and 
            <see cref="M:Perst.IBidirectionalEnumerator.MovePrevious"/> - to the element with index <b>start-1</b>.
            Standard enumerator is equivalent to <b>start == -1</b>.
            </param>
            <returns>iterator through the list elements starting from element with specified position</returns>
        </member>
        <member name="T:Perst.Code">
            <summary>
            Class representing abstract syntax tree generated by query code generator
            </summary>
        </member>
        <member name="T:Perst.Query">
            <summary> 
            Class representing JSQL query. JSQL allows to select members of Perst collections 
            using SQL like predicate. Almost all Perst collections have select() method 
            which execute arbitrary JSQL query. But it is also possible to create Query instance explicitely, 
            Using storage.createQuery class. In this case it is possible to specify query with parameters, 
            once prepare query and then multiple times specify parameters and execute it. 
            Also Query interface allows to specify <i>indices</i> and <i>resolvers</i>.
            JSQL can use arbitrary Perst <see cref="T:Perst.GenericIndex"/> to perform fast selection if object
            instead of sequeial search. And user provided <i>resolver</i> allows to substitute SQL joins.
            </summary>
        </member>
        <member name="M:Perst.Query.Select(System.Type,System.Collections.IEnumerable,System.String)">
            <summary> Execute query
            </summary>
            <param name="cls">class of inspected objects
            </param>
            <param name="e">enumerable collection for sequential access to objects in the table
            </param>
            <param name="predicate">selection crieria
            </param>
            <returns> 
            iterator through selected objects
            </returns>
        </member>
        <member name="M:Perst.Query.Select(System.String,System.Collections.IEnumerable,System.String)">
            <summary> Execute query
            </summary>
            <param name="className">name of the class of inspected objects
            </param>
            <param name="e">enumerable collection for sequential access to objects in the table
            </param>
            <param name="predicate">selection crieria
            </param>
            <returns> iterator through selected objects
            </returns>
        </member>
        <member name="M:Perst.Query.Prepare(System.Type,System.String)">
            <summary> Prepare SQL statement
            </summary>
            <param name="cls">class of iterated objects
            </param>
            <param name="predicate">selection crieria with '?' placeholders for parameter value
            </param>
        </member>
        <member name="M:Perst.Query.Prepare(System.String,System.String)">
            <summary> Prepare SQL statement
            </summary>
            <param name="className">name of the class of iterated objects
            </param>
            <param name="predicate">selection crieria with '?' placeholders for parameter value
            </param>
        </member>
        <member name="M:Perst.Query.Execute">
            <summary> Execute prepared query using iterator obtained from index registered by Query.SetClassExtent method
            </summary>
            <returns> iterator through selected objects
            </returns>
        </member>
        <member name="M:Perst.Query.Execute(System.Collections.IEnumerable)">
            <summary> Execute prepared query
            </summary>
            <param name="iterator">iterator for sequential and direct access to objects in the table
            </param>
            <returns> iterator through selected objects
            </returns>
        </member>
        <member name="M:Perst.Query.EnableRuntimeErrorReporting(System.Boolean)">
            <summary> Enable or disable reporting of runtime errors on console.
            Runtime errors during JSQL query are reported in two ways:
            <OL>
            <LI>If query error reporting is enabled then message is  printed to System.err</LI>
            <LI>If storage listener is registered, then JSQLRuntimeError of method listener is invoked</LI>
            </OL>     
            By default reporting to System.err is enabled.
            </summary>
            <param name="enabled">if <b>true</b> then reportnig is enabled
            </param>
        </member>
        <member name="M:Perst.Query.SetResolver(System.Type,System.Type,Perst.Resolver)">
            <summary> Specify resolver. Resolver can be used to replaced SQL JOINs: given object ID, 
            it will provide reference to the resolved object
            </summary>
            <param name="original">class which instances will have to be resolved
            </param>
            <param name="resolved">class of the resolved object
            </param>
            <param name="resolver">class implementing Resolver interface
            </param>
        </member>
        <member name="M:Perst.Query.AddIndex(System.String,Perst.GenericIndex)">
            <summary> Add index which can be used to optimize query execution (replace sequential search with direct index access)
            </summary>
            <param name="key">indexed field
            </param>
            <param name="index">implementation of index
            </param>
        </member>
        <member name="M:Perst.Query.SetIndexProvider(Perst.IndexProvider)">
             <summary>
             Set index provider for this query.
             Available indices shoudl be either registered using addIndex method, either 
             should be accessible through index provider
             </summary>
             <param name="indexProvider">index provider</param>
            
        </member>
        <member name="M:Perst.Query.SetClass(System.Type)">
            <summary>
            Set class for which this query will be executed
            </summary>
            <param name="type">queried class</param>
        </member>
        <member name="M:Perst.Query.SetClassExtent(System.Collections.IEnumerable,Perst.ClassExtentLockType)">
             <summary>
             Set class extent used to obtain iterator through all instances of this class
             </summary>
             <param name="set">class extent</param>
             <param name="lockType">type of the lock which should be obtained for the set before query execution</param>
            
        </member>
        <member name="M:Perst.Query.GetCodeGenerator(System.Type)">
             <summary>
             Get query code generator for the specified class
             </summary>
             <param name="cls">class for which query is constructed</param>
             <returns>code generator for the specified class</returns>
            
        </member>
        <member name="M:Perst.Query.GetCodeGenerator">
             <summary>
             Get query code generator for class associated with the query by Query.setClass method
             </summary>
             <returns>code generator for class associated with the query</returns>
            
        </member>
        <member name="P:Perst.Query.Item(System.Int32)">
            <summary>Set or get value of query parameter
            </summary>
            <param name="i">parameters index (1 based)
            </param>
        </member>
        <member name="T:Perst.Link">
            <summary> Interface for one-to-many relation. There are two types of relations:
            embedded (when references to the relarted obejcts are stored in lreation
            owner obejct itself) and stanalone (when relation is separate object, which contains
            the reference to the relation owner and relation members). Both kinds of relations
            implements Link interface. Embedded relation is created by Storage.createLink method
            and standalone relation is represented by Relation persistent class created by
            Storage.createRelation method.
            </summary>
        </member>
        <member name="T:Perst.GenericLink">
            <summary>
            Common interface for all links
            </summary>
        </member>
        <member name="M:Perst.GenericLink.Size">
            <summary> Get number of the linked objects 
            </summary>
            <returns>the number of related objects
            
            </returns>
        </member>
        <member name="M:Perst.GenericLink.GetRaw(System.Int32)">
            <summary> Get related object by index without loading it.
            Returned object can be used only to get it OID or to compare with other objects using
            <b>Equals</b> method
            </summary>
            <param name="i">index of the object in the relation
            </param>
            <returns>stub representing referenced object
            
            </returns>
        </member>
        <member name="M:Perst.GenericLink.SetOwner(System.Object)">
            <summary>
            Set owner object for this link. Owner is persistent object contaning this link.
            This method is mostly used by storage itself, but can also used explicityl by programmer if
            link component of one persistent object is assigned to component of another persistent object
            </summary>
            <param name="owner">Link owner</param>
        </member>
        <member name="M:Perst.GenericLink.Unpin">
            <summary>
            Replace all direct references to linked objects with stubs. 
            This method is needed tyo avoid memory exhaustion in case when 
            there is a large numebr of objectys in databasse, mutually
            refefencing each other (each object can directly or indirectly 
            be accessed from other objects).
            </summary>
        </member>
        <member name="M:Perst.GenericLink.Pin">
            <summary>
            Replace references to elements with direct references.
            It will impove spped of manipulations with links, but it can cause
            recursive loading in memory large number of objects and as a result - memory
            overflow, because garabge collector will not be able to collect them
            </summary>
        </member>
        <member name="M:Perst.Link.Get(System.Int32)">
            <summary> Get related object by index
            </summary>
            <param name="i">index of the object in the relation
            </param>
            <returns>referenced object
            
            </returns>
        </member>
        <member name="M:Perst.Link.Set(System.Int32,System.Object)">
            <summary> Replace i-th element of the relation
            </summary>
            <param name="i">index in the relartion
            </param>
            <param name="obj">object to be included in the relation     
            
            </param>
        </member>
        <member name="M:Perst.Link.Remove(System.Int32)">
            <summary> Remove object with specified index from the relation
            </summary>
            <param name="i">index in the relartion
            
            </param>
        </member>
        <member name="M:Perst.Link.Remove(System.Object)">
            <summary> Remove object from the relation
            </summary>
            <param name="obj">object to be removed
            </param>
            <returns><b>true</b> if member was successfully removed or <b>false</b> if member is not found</returns>
        </member>
        <member name="M:Perst.Link.Insert(System.Int32,System.Object)">
            <summary> Insert new object in the relation
            </summary>
            <param name="i">insert poistion, should be in [0,size()]
            </param>
            <param name="obj">object inserted in the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.Add(System.Object)">
            <summary> Add new object to the relation
            </summary>
            <param name="obj">object inserted in the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.AddAll(System.Object[])">
            <summary> Add all elements of the array to the relation
            </summary>
            <param name="arr">array of obects which should be added to the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.AddAll(System.Object[],System.Int32,System.Int32)">
            <summary> Add specified elements of the array to the relation
            </summary>
            <param name="arr">array of obects which should be added to the relation
            </param>
            <param name="from">index of the first element in the array to be added to the relation
            </param>
            <param name="length">number of elements in the array to be added in the relation
            
            </param>
        </member>
        <member name="M:Perst.Link.AddAll(Perst.Link)">
            <summary> Add all object members of the other relation to this relation
            </summary>
            <param name="link">another relation
            
            </param>
        </member>
        <member name="M:Perst.Link.ToArray">
            <summary> Get relation members as array of objects
            </summary>
            <returns>created array</returns>
        </member>
        <member name="M:Perst.Link.ToRawArray">
            <summary> 
            Return array with relation members. Members are not loaded and 
            size of the array can be greater than actual number of members. 
            </summary>
            <returns>array of object with relation members used in implementation of Link class
            </returns>
        </member>
        <member name="M:Perst.Link.ToArray(System.Type)">
            <summary> Get relation members as array with specifed element type
            </summary>
            <param name="elemType">element type of created array</param>
            <returns>created array</returns>
        </member>
        <member name="M:Perst.Link.Contains(System.Object)">
            <summary> Checks if relation contains specified object
            </summary>
            <param name="obj">specified object
            
            </param>
        </member>
        <member name="M:Perst.Link.ContainsElement(System.Int32,System.Object)">
            <summary>Check if i-th element of Link is the same as specified obj
            </summary>
            <param name="i"> element index</param>
            <param name="obj">specified object</param>
            <returns><b>true</b> if i-th element of Link reference the same object as "obj"</returns>
        </member>
        <member name="M:Perst.Link.IndexOf(System.Object)">
            <summary> Get index of the specified object in the relation
            </summary>
            <param name="obj">specified object
            </param>
            <returns>zero based index of the object or -1 if object is not in the relation
            
            </returns>
        </member>
        <member name="M:Perst.Link.GetEnumerator(System.Int32)">
            <summary>
            Get bidirectional enumerator started with specified current position
            </summary>
            <param name="start">position of the first element. 
            After creation of this enumerator <b>IEnumerator.Current</b> property points to the list 
            element with index <b>start</b> (if any), following <b>IEnumerator.MoveNext</b> moves 
            enumerator current position to the element with index <b>star+1</b> and 
            <b>IEnumerator.MovePrevious</b> - to the element with index <b>start-1</b>.
            Standard enumerator is equivalent to <b>start == -1</b>.
            </param>
            <returns>iterator through the list elements starting from element with specified position</returns>
        </member>
        <member name="P:Perst.Link.Length">
            <summary>Number of the linked objects 
            </summary>
        </member>
        <member name="P:Perst.Link.Item(System.Int32)">
            <summary> Access element by index
            </summary>
        </member>
        <member name="T:Perst.PersistentEnumerator">
            <summary>Interface implemented by all Perst enumerators allowing to get Oid of the current object
            </summary>
        </member>
        <member name="P:Perst.PersistentEnumerator.CurrentOid">
            <summary>Get OID of the current object</summary>
        </member>
        <member name="T:Perst.IBidirectionalEnumerator">
            <summary>
             Enumerator for moving in both directions
             </summary>
        </member>
        <member name="M:Perst.IBidirectionalEnumerator.MovePrevious">
            <summary>
            Move curent position to the previous element
            </summary>
            <returns>true if previous element exists, false otherwise
            </returns>returns>
        </member>
        <member name="T:Perst.CodeGenerator">
            <summary>
            Code generator for JSQL queries.
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.Predicate(Perst.Code)">
            <summary>
            Set query predicate code
            </summary>
            <param name="code">AST constructed using CodeGenerator methods</param>
        </member>
        <member name="M:Perst.CodeGenerator.Literal(System.Object)">
            <summary>
            Literal constant 
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.List(Perst.Code[])">
            <summary>
            List of alternatives for IN operator 
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.Parameter(System.Int32,System.Type)">
            <summary>
            Query parameter
            </summary>
            <param name="n">parameter index (0 based)</param>
            <param name="type">parameter type</param>
        </member>
        <member name="M:Perst.CodeGenerator.Field(System.String)">
            <summary>
            Get self field
            </summary>
            <param name="name">field name</param>
        </member>
        <member name="M:Perst.CodeGenerator.Field(Perst.Code,System.String)">
            <summary>
            Get field
            </summary>
            <param name="baseExpr">target object</param>
            <param name="name">field name</param>
        </member>
        <member name="M:Perst.CodeGenerator.Invoke(Perst.Code,System.String,Perst.Code[])">
            <summary>
            Invoke method
            </summary>
            <param name="baseExpr">invocation  target</param>
            <param name="name">method name</param>
            <param name="arguments">method arguments</param>
        </member>
        <member name="M:Perst.CodeGenerator.Invoke(System.String,Perst.Code[])">
            <summary>
            Invoke self method
            </summary>
            <param name="name">method name</param>
            <param name="arguments">method arguments</param>
        </member>
        <member name="M:Perst.CodeGenerator.Lower(Perst.Code)">
            <summary>
            Convert string to lower case
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.Upper(Perst.Code)">
            <summary>
            Convert string to upper case
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.Length(Perst.Code)">
            <summary>
            Get array length
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.GetAt(Perst.Code,Perst.Code)">
            <summary>
            Get array element
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.Integer(Perst.Code)">
            <summary>
            Convert real to integer
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.Real(Perst.Code)">
            <summary>
            Convert integer to real
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.String(Perst.Code)">
            <summary>
            Convert integer/real/date to string
            </summary>
        </member>
        <member name="M:Perst.CodeGenerator.OrderBy(System.String,System.Boolean)">
            <summary>
            Add order by clause. It is possible to invoke this method several times - in this case
            result will be sorted by all specified fields in the correspondent order
            </summary>
            <param name="name">field name by which sort should be performed</param>
            <param name="ascent">true for ascent order, false for descent order</param>
        </member>
        <member name="M:Perst.CodeGenerator.OrderBy(System.String)">
            <summary>
            Add order by clause. It is possible to invoke this method several times - in this case
            result will be sorted by all specified fields in the correspondent order
            </summary>
            <param name="name">field name by which sort should be performed</param>
        </member>
        <member name="T:Perst.Index">
            <summary> Interface of object index.
            Index is used to provide fast access to the object by key. 
            Object in the index are stored ordered by key value. 
            It is possible to select object using exact value of the key or 
            select set of objects which key belongs to the specified interval 
            (each boundary can be specified or unspecified and can be inclusive or exclusive)
            Key should be of scalar, String, java.util.Date or peristent object type.
            </summary>
        </member>
        <member name="T:Perst.GenericIndex">
            <summary> Interface of object index.
            Index is used to provide fast access to the object by key. 
            Object in the index are stored ordered by key value. 
            It is possible to select object using exact value of the key or 
            select set of objects which key belongs to the specified interval 
            (each boundary can be specified or unspecified and can be inclusive or exclusive)
            Key should be of scalar, String, DateTime or peristent object type.
            </summary>
        </member>
        <member name="M:Perst.GenericIndex.Get(Perst.Key)">
            <summary> Get object by key (exact match)     
            </summary>
            <param name="key">wrapper of the specified key. It should match with type of the index and should be inclusive.
            </param>
            <returns>object with this value of the key or <b>null</b> if key nmot found
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) exception if there are more than 
            one objects in the index with specified value of the key.
            
            </exception>
        </member>
        <member name="M:Perst.GenericIndex.Get(Perst.Key,Perst.Key)">
            <summary> Get objects which key value belongs to the specified range.
            Either from boundary, either till boundary either both of them can be <b>null</b>.
            In last case the method returns all objects from the index.
            </summary>
            <param name="from">low boundary. If <b>null</b> then low boundary is not specified.
            Low boundary can be inclusive or exclusive. 
            </param>
            <param name="till">high boundary. If <b>null</b> then high boundary is not specified.
            High boundary can be inclusive or exclusive. 
            </param>
            <returns>array of objects which keys belongs to the specified interval, ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.GetPrefix(System.String)">
            <summary> Get objects which key starts with specifid prefix.
            </summary>
            <param name="prefix">String key prefix</param>
            <returns>array of objects which key starts with specifid prefix, ordered by key value 
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.PrefixSearch(System.String)">
            <summary> 
            Locate all objects which key is prefix of specified word.
            </summary>
            <param name="word">string which prefixes are located in index</param>
            <returns>array of objects which key is prefix of specified word, ordered by key value
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.Size">
            <summary> Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.ToArray">
            <summary> Get all objects in the index as array orderd by index key
            </summary>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.ToArray(System.Type)">
            <summary> Get all objects in the index as array of specified type ordered by index key
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.GetEnumerator(Perst.Key,Perst.Key)">
             <summary>
             Get enumerator for traversing objects in ascent order belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <returns>selection enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.GetEnumerator(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get enumerator for traversing objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><b>IterationOrder.AscentOrder</b> or <b>IterationOrder.DescentOrder</b></param>
             <returns>selection enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.GetEnumerator(System.String)">
             <summary>
             Get enumerator for traversing objects in ascent order which key starts with specified prefix. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="prefix">String key prefix</param>
             <returns>selection enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.Range(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get enumerable collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><b>IterationOrder.AscentOrder</b> or <b>IterationOrder.DescentOrder</b></param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.Range(Perst.Key,Perst.Key)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.Reverse">
             <summary>
             Get enumerable collection of objects in descending order
             </summary>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.StartsWith(System.String)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index which key starts with specified prefix. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="prefix">String key prefix</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.GetDictionaryEnumerator">
             <summary>
             Get enumerator for traversing all entries in the index 
             You should not update/remove or add members to the index during iteration
             </summary>
             <returns>entry enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.GetDictionaryEnumerator(Perst.Key,Perst.Key,Perst.IterationOrder)">
             <summary>
             Get enumerator for traversing entries in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><b>AscanrOrder</b> or <b>DescentOrder</b></param>
             <returns>selection enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.Get(System.Object)">
            <summary> Get object by key (exact match)     
            </summary>
            <param name="key">specified key value. It should match with type of the index and should be inclusive.
            </param>
            <returns>object with this value of the key or <b>null</b> if key nmot found
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) exception if there are more than 
            one objects in the index with specified value of the key.
            
            </exception>
        </member>
        <member name="M:Perst.GenericIndex.Get(System.Object,System.Object)">
            <summary> Get objects which key value belongs to the specified inclusive range.
            Either from boundary, either till boundary either both of them can be <b>null</b>.
            In last case the method returns all objects from the index.
            </summary>
            <param name="from">Inclusive low boundary. If <b>null</b> then low boundary is not specified.
            </param>
            <param name="till">Inclusive high boundary. If <b>null</b> then high boundary is not specified.
            </param>
            <returns>array of objects which keys belongs to the specified interval, ordered by key value
            
            </returns>
        </member>
        <member name="M:Perst.GenericIndex.GetEnumerator(System.Object,System.Object,Perst.IterationOrder)">
             <summary>
             Get enumerator for traversing objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <param name="order"><b>IterationOrder.AscentOrder</b> or <b>IterationOrder.DescentOrder</b></param>
             <returns>selection enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.GetEnumerator(System.Object,System.Object)">
             <summary>
             Get enumerator for traversing objects in ascent order belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Low boundary. If <b>null</b> then low boundary is not specified.
             Low boundary can be inclusive or exclusive.</param>
             <param name="till">High boundary. If <b>null</b> then high boundary is not specified.
             High boundary can be inclusive or exclusive.</param>
             <returns>selection enumerator</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.Range(System.Object,System.Object,Perst.IterationOrder)">
             <summary>
             Get enumerable collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Inclusive low boundary. If <b>null</b> then low boundary is not specified.</param>
             <param name="till">Inclusive high boundary. If <b>null</b> then high boundary is not specified.</param>
             <param name="order"><b>IterationOrder.AscentOrder</b> or <b>IterationOrder.DescentOrder</b></param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.Range(System.Object,System.Object)">
             <summary>
             Get enumerable ascent ordered collection of objects in the index with key belonging to the specified range. 
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="from">Inclusive low boundary. If <b>null</b> then low boundary is not specified.</param>
             <param name="till">Inclusive high boundary. If <b>null</b> then high boundary is not specified.</param>
             <returns>enumerable collection</returns>
            
        </member>
        <member name="M:Perst.GenericIndex.GetAt(System.Int32)">
            <summmary>
            Get element at specified position. This methid is efficient only for random access indices
            </summmary>
            <param name="i">position of element in the index</param>
            <returns>object at sepcified position</returns>
            <exception cref="T:System.IndexOutOfRangeException">System.IndexOutOfRangeException if position is less than 0 or greater or equal than index size</exception> 
        </member>
        <member name="M:Perst.GenericIndex.IndexOf(Perst.Key)">
            <summary>
            Get position of the first element with specified key. This method is efficient only for random access indices
            </summary>
            <param name="key">located key</param>
            <returns>position of the first element with this key or -1 if no such element is found</returns>
        </member>
        <member name="M:Perst.GenericIndex.GetDictionaryEnumerator(System.Int32,Perst.IterationOrder)">
             <summary>
             Get dictionary enumerator of objects in the index starting with specified position.
             This methid is efficient only for random access indices
             You should not update/remove or add members to the index during iteration
             </summary>
             <param name="start">Start position in the index. First <b>pos</b> elements will be skipped.</param>
             <param name="order"><b>IterationOrder.AscentOrder</b> or <b>IterationOrder.DescentOrder</b></param>
             <returns>dictionary enumerator</returns>
            
        </member>
        <member name="P:Perst.GenericIndex.KeyType">
            <summary>
            Get type of index key
            </summary>
            <returns>type of index key</returns>
        </member>
        <member name="P:Perst.GenericIndex.Item(System.Object)">
            <summary> Access element by key
            </summary>
        </member>
        <member name="P:Perst.GenericIndex.Item(System.Object,System.Object)">
            <summary> Get objects which key value belongs to the specified range.
            </summary>
        </member>
        <member name="P:Perst.GenericIndex.IsUnique">
            <summary>
            Check if index is unique
            </summary>
        </member>
        <member name="M:Perst.Index.Put(Perst.Key,System.Object)">
            <summary> Put new object in the index. 
            </summary>
            <param name="key">object key wrapper
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns><b>true</b> if object is successfully inserted in the index, 
            <b>false</b> if index was declared as unique and there is already object with such value
            of the key in the index. 
            </returns>
        </member>
        <member name="M:Perst.Index.Put(System.Object,System.Object)">
            <summary> Put new object in the index. 
            </summary>
            <param name="key">object key value
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns><b>true</b> if object is successfully inserted in the index, 
            <b>false</b> if index was declared as unique and there is already object with such value
            of the key in the index. 
            
            </returns>
        </member>
        <member name="M:Perst.Index.Set(Perst.Key,System.Object)">
            <summary> Associate new value with the key. If there is already object with such key in the index, 
            then it will be removed from the index and new value associated with this key.
            </summary>
            <param name="key">object key wrapper
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns>object previously associated with this key, <b>null</b> if there was no such object
            </returns>
        </member>
        <member name="M:Perst.Index.Set(System.Object,System.Object)">
            <summary> Associate new value with the key. If there is already object with such key in the index, 
            then it will be removed from the index and new value associated with this key.
            </summary>
            <param name="key">object key value
            </param>
            <param name="obj">object associated with this key. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns>object previously associated with this key, <b>null</b> if there was no such object
            </returns>
        </member>
        <member name="M:Perst.Index.Remove(Perst.Key,System.Object)">
            <summary> Remove object with specified key from the tree.
            </summary>
            <param name="key">wrapper of the value of the key of removed object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index
            
            </exception>
        </member>
        <member name="M:Perst.Index.Remove(System.Object,System.Object)">
            <summary> Remove object with specified key from the tree.
            </summary>
            <param name="key">value of the key of removed object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index
            
            </exception>
        </member>
        <member name="M:Perst.Index.Remove(Perst.Key)">
            <summary> Remove key from the unique index.
            </summary>
            <param name="key">wrapper of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="M:Perst.Index.RemoveKey(System.Object)">
            <summary> Remove key from the unique index.
            </summary>
            <param name="key">value of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOV_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="T:Perst.FieldIndex">
            <summary> Interface of indexed field. 
            Index is used to provide fast access to the object by the value of indexed field. 
            Objects in the index are stored ordered by the value of indexed field. 
            It is possible to select object using exact value of the key or 
            select set of objects which key belongs to the specified interval 
            (each boundary can be specified or unspecified and can be inclusive or exclusive)
            Key should be of scalar, String, DateTime or peristent object type.
            </summary>
        </member>
        <member name="M:Perst.FieldIndex.Contains(System.Object)">
            <summary> 
            Check if index contains specified object
            </summary>
            <param name="obj">object to be searched in the index. Object should contain indexed field. 
            </param>
            <returns><b>true</b> if object is present in the index, <b>false</b> otherwise
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Put(System.Object)">
            <summary> Put new object in the index. 
            </summary>
            <param name="obj">object to be inserted in index. Object should contain indexed field. 
            Object can be not yet persistent, in this case its forced to become persistent by assigning OID to it.
            </param>
            <returns><b>true</b> if object is successfully inserted in the index, 
            <b>false</b> if index was declared as unique and there is already object with such value
            of the key in the index. 
            
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Set(System.Object)">
            <summary>
            Associate new object with the key specified by object field value. 
            If there is already object with such key in the index, 
            then it will be removed from the index and new value associated with this key.
            </summary>
            <param name="obj">object to be inserted in index. Object should contain indexed field. 
            Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <returns>object previously associated with this key, <b>null</b> if there was no such object
            </returns>
        </member>
        <member name="M:Perst.FieldIndex.Append(System.Object)">
            <summary>
            Assign to the integer indexed field unique autoicremented value and 
            insert object in the index. 
            </summary>
            <param name="obj">object to be inserted in index. Object should contain indexed field
            of integer (<b>int</b> or <b>long</b>) type.
            This field is assigned unique value (which will not be reused while 
            this index exists) and object is marked as modified.
            Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <exception cref="T:Perst.StorageError"><b>StorageError(StorageError.ErrorCode.INCOMPATIBLE_KEY_TYPE)</b> 
            is thrown when indexed field has type other than <b>int</b> or <b>long</b></exception>
        </member>
        <member name="M:Perst.FieldIndex.BulkLoad(System.Collections.IEnumerable)">
             <summary> 
             Bulk load of objects in the index. This method first sort all members by index key to improve
             locality of references duing insert. 
             </summary>
             <param name="members">loaded members</param> 
            
        </member>
        <member name="M:Perst.FieldIndex.Remove(System.Object)">
            <summary> Remove object from the index
            </summary>
            <param name="obj">object removed from the index. Object should contain indexed field. 
            </param>
            <returns><b>true</b> if member was successfully removed or <b>false</b> if member is not found</returns>
        </member>
        <member name="M:Perst.FieldIndex.Remove(Perst.Key)">
            <summary> Remove object with specified key from the unique index.
            </summary>
            <param name="key">wrapper of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="M:Perst.FieldIndex.RemoveKey(System.Object)">
            <summary> Remove object with specified key from the unique index.
            </summary>
            <param name="key">value of removed key
            </param>
            <returns>removed object</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such key in the index,
            or StorageError(StorageError.ErrorCode.KEY_NOT_UNIQUE) if index is not unique.
            
            </exception>
        </member>
        <member name="P:Perst.FieldIndex.IndexedClass">
            <summary>
            Get class obejct objects which can be inserted in this index
            </summary>
            <returns>class specified in Storage.createFielIndex method</returns>
        </member>
        <member name="P:Perst.FieldIndex.KeyField">
            <summary>
            Get key field
            </summary>
            <returns>field info for key field</returns>
        </member>
        <member name="P:Perst.FieldIndex.IsCaseInsensitive">
            <summary>
            Check if field index is case insensitive
            </summary>
        </member>
        <member name="T:Perst.SpatialIndex">
            <summary> Interface of object spatial index.
            Spatial index is used to allow fast selection of spatial objects belonging to the specified rectangle.
            Spatial index is implemented using Guttman R-Tree with quadratic split algorithm.
            </summary>
        </member>
        <member name="M:Perst.SpatialIndex.Get(Perst.Rectangle)">
            <summary>
            Find all objects located in the selected rectangle
            </summary>
            <param name="r">selected rectangle
            </param>
            <returns>array of objects which enveloping rectangle intersects with specified rectangle
            </returns>             
        </member>
        <member name="M:Perst.SpatialIndex.Put(Perst.Rectangle,System.Object)">
            <summary>
            Put new object in the index. 
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj"> object associated with this rectangle. Object can be not yet persistent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
        </member>
        <member name="M:Perst.SpatialIndex.Remove(Perst.Rectangle,System.Object)">
            <summary>
            Remove object with specified enveloping rectangle from the tree.
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_FOUND) exception if there is no such key in the index
            </exception>
        </member>
        <member name="M:Perst.SpatialIndex.Size">
            <summary>
            Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            </returns>
        </member>
        <member name="M:Perst.SpatialIndex.Overlaps(Perst.Rectangle)">
            <summary>
            Get enumerator for objects located in the selected rectangle
            </summary>
            <param name="r">Selected rectangle</param>
            <returns>enumerable collection for objects which enveloping rectangle overlaps with specified rectangle
            </returns>
        </member>
        <member name="M:Perst.SpatialIndex.GetDictionaryEnumerator(Perst.Rectangle)">
            <summary>
            Get dictionary enumerator for objects located in the selected rectangle
            </summary>
            <param name="r">Selected rectangle</param>
            <returns>dictionary enumerator for objects which enveloping rectangle overlaps with specified rectangle
            </returns>
        </member>
        <member name="M:Perst.SpatialIndex.GetDictionaryEnumerator">
            <summary>
            Get dictionary enumerator for all objects in the index
            </summary>
            <returns>dictionary enumerator for all objects in the index
            </returns>
        </member>
        <member name="P:Perst.SpatialIndex.WrappingRectangle">
            <summary>
            Get wrapping rectangle 
            </summary>
            <returns>Minimal rectangle containing all rectangles in the index     
            If index is empty <i>empty rectangle</i> (double.MaxValue, double.MaxValue, double.MinValue, double.MinValue)
            is returned.
            </returns>
        </member>
        <member name="T:Perst.ISet">
            <summary>
             Interface of objects set
             </summary>
        </member>
        <member name="M:Perst.ISet.Contains(System.Object)">
            <summary>
            Check if set contains specified element
            </summary>
            <param name="o">checked element</param>
            <returns><b>true</b> if elementis in set</returns>
        </member>
        <member name="M:Perst.ISet.ContainsAll(System.Collections.ICollection)">
            <summary>
            Check if the set contains all members from specified collection
            </summary>
            <param name="c">collection specifying members</param>
            <returns><b>true</b> if all members of enumerator are present in the set</returns>
        </member>
        <member name="M:Perst.ISet.Add(System.Object)">
            <summary>
            Add new element to the set
            </summary>
            <param name="o">element to be added</param>
        </member>
        <member name="M:Perst.ISet.AddAll(System.Collections.ICollection)">
            <summary>
            Add all elements from specified collection to the set
            </summary>
            <param name="c">collection specifying members</param>
            <returns><b>true</b> if at least one element was added to the set,
            <b>false</b> if now new elements were added</returns>
        </member>
        <member name="M:Perst.ISet.Remove(System.Object)">
            <summary> 
            Remove element from the set
            </summary>
            <param name="o">removed element</param>
            <returns><b>true</b> if element was successfully removed,
            <b>false</b> if there is not such element in the set</returns>
        </member>
        <member name="M:Perst.ISet.RemoveAll(System.Collections.ICollection)">
            <summary>
            Remove from the set all members from the specified enumerator
            </summary>
            <param name="c">collection specifying members</param>
            <returns></returns>
        </member>
        <member name="M:Perst.ISet.ToArray">
            <summary>
            Copy all set members to an array
            </summary>
            <returns>array of object with set members</returns>
        </member>
        <member name="M:Perst.ISet.ToArray(System.Type)">
            <summary>
            Copy all set members to an array of specified type
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of specified type with members of the set</returns>
        </member>
        <member name="T:Perst.SpatialIndexR2">
            <summary> Interface of object spatial index.
            Spatial index is used to allow fast selection of spatial objects belonging to the specified rectangle.
            Spatial index is implemented using Guttman R-Tree with quadratic split algorithm.
            </summary>
        </member>
        <member name="M:Perst.SpatialIndexR2.Get(Perst.RectangleR2)">
            <summary>
            Find all objects located in the selected rectangle
            </summary>
            <param name="r">selected rectangle
            </param>
            <returns>array of objects which enveloping rectangle intersects with specified rectangle
            </returns>             
        </member>
        <member name="M:Perst.SpatialIndexR2.Put(Perst.RectangleR2,System.Object)">
            <summary>
            Put new object in the index. 
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj"> object associated with this rectangle. Object can be not yet persistent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
        </member>
        <member name="M:Perst.SpatialIndexR2.Remove(Perst.RectangleR2,System.Object)">
            <summary>
            Remove object with specified enveloping rectangle from the tree.
            </summary>
            <param name="r">enveloping rectangle for the object
            </param>
            <param name="obj">object removed from the index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_FOUND) exception 
            if there is no such key in the index
            </exception>
        </member>
        <member name="M:Perst.SpatialIndexR2.Size">
            <summary>
            Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            </returns>
        </member>
        <member name="M:Perst.SpatialIndexR2.Overlaps(Perst.RectangleR2)">
            <summary>
            Get enumerator for objects located in the selected rectangle
            </summary>
            <param name="r">Selected rectangle</param>
            <returns>enumerable collection for objects which enveloping rectangle overlaps with specified rectangle
            </returns>
        </member>
        <member name="M:Perst.SpatialIndexR2.GetDictionaryEnumerator(Perst.RectangleR2)">
            <summary>
            Get dictionary enumerator for objects located in the selected rectangle
            </summary>
            <param name="r">Selected rectangle</param>
            <returns>dictionary enumerator for objects which enveloping rectangle overlaps with specified rectangle
            </returns>
        </member>
        <member name="M:Perst.SpatialIndexR2.GetDictionaryEnumerator">
            <summary>
            Get dictionary enumerator for all objects in the index
            </summary>
            <returns>dictionary enumerator for all objects in the index
            </returns>
        </member>
        <member name="P:Perst.SpatialIndexR2.WrappingRectangle">
            <summary>
            Get wrapping rectangle 
            </summary>
            <returns>Minimal rectangle containing all rectangles in the index     
            If index is empty <i>empty rectangle</i> (double.MaxValue, double.MaxValue, double.MinValue, double.MinValue)
            is returned.
            </returns>
        </member>
        <member name="T:Perst.FullText.FullTextIndex">
            <summary> Full text search index.
            This index split document text in words, perform stemming of the words and build inverse index.
            Full text index is able to execute search queries with logical operators (AND/OR/NOT) and 
            strict match. Returned results are ordered by rank, which includes inverse document frequency (IDF),
            frequency of word in the document, occurrence kind and nearness of query keywords in the document text.
            </summary>
        </member>
        <member name="M:Perst.FullText.FullTextIndex.Add(Perst.FullText.FullTextSearchable)">
            <summary> Add document to the index</summary>
            <param name="obj">document to be added
            </param>
        </member>
        <member name="M:Perst.FullText.FullTextIndex.Add(System.Object,System.IO.TextReader,System.String)">
            <summary> Add document to the index</summary>
            <param name="obj">document to be added
            </param>
            <param name="text">document text to be indexed
            </param>
            <param name="language">language of the text
            </param>
        </member>
        <member name="M:Perst.FullText.FullTextIndex.Delete(System.Object)">
            <summary> Delete document from the index</summary>
            <param name="obj">document to be deleted
            </param>
        </member>
        <member name="M:Perst.FullText.FullTextIndex.Clear">
            <summary>
            Remove all elements from full text index
            </summary>
        </member>
        <member name="M:Perst.FullText.FullTextIndex.Search(System.String,System.String,System.Int32,System.Int32)">
            <summary> Parse and execute full text search query</summary>
            <param name="query">text of the query
            </param>
            <param name="language">language if the query
            </param>
            <param name="maxResults">maximal amount of selected documents
            </param>
            <param name="timeLimit">limit for query execution time
            </param>
            <returns> result of query execution ordered by rank or null in case of empty or incorrect query
            </returns>
        </member>
        <member name="M:Perst.FullText.FullTextIndex.Search(Perst.FullText.FullTextQuery,System.Int32,System.Int32)">
            <summary> Execute full text search query</summary>
            <param name="query">prepared query
            </param>
            <param name="maxResults">maximal amount of selected documents
            </param>
            <param name="timeLimit">limit for query execution time
            </param>
            <returns> result of query execution ordered by rank or null in case of empty or incorrect query
            </returns>
        </member>
        <member name="P:Perst.FullText.FullTextIndex.NumberOfWords">
            <summary> Get total number of different words in all documents</summary>
        </member>
        <member name="P:Perst.FullText.FullTextIndex.NumberOfDocuments">
            <summary> Get total number of indexed documents</summary>
        </member>
        <member name="P:Perst.FullText.FullTextIndex.Helper">
            <summary> Get full text search helper</summary>
        </member>
        <member name="T:Perst.FullText.FullTextQueryVisitor">
            <summary> Base class for full text query visitor</summary>
        </member>
        <member name="T:Perst.MultiFieldIndex">
            <summary> Interface of multifield index. 
            </summary>
        </member>
        <member name="P:Perst.MultiFieldIndex.KeyFields">
            <summary>
            Get fields used as a key
            </summary>
            <returns>array of index key fields</returns>
        </member>
        <member name="T:Perst.FullText.FullTextSearchable">
            <summary> Interface for classes which are able to extract text and its language themselves.</summary>
        </member>
        <member name="P:Perst.FullText.FullTextSearchable.Text">
            <summary> Get document text</summary>
        </member>
        <member name="P:Perst.FullText.FullTextSearchable.Language">
            <summary> Get document language (null if unknown)</summary>
        </member>
        <member name="T:Perst.BitIndex">
            <summary>
            Interface of bit index.
            Bit index allows to effiicently search object with specified 
            set of properties. Each object has associated mask of 32 bites. 
            Meaning of bits is application dependent. Usually each bit stands for
            some binary or boolean property, for example "sex", but it is possible to 
            use group of bits to represent enumerations with more possible values.
            </summary>
        </member>
        <member name="M:Perst.BitIndex.Get(System.Object)">
            <summary>
            Get properties of specified object
            </summary>
            <param name="obj">object which properties are requested</param>
            <returns>bit mask associated with this objects</returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.KEY_NOT_FOUND) exception if there is no such object in the index
            </exception>
        </member>
        <member name="M:Perst.BitIndex.Put(System.Object,System.Int32)">
            <summary>
            Put new object in the index. If such objct already exists in index, then its
            mask will be rewritten 
            </summary>
            <param name="obj">object to be placed in the index. Object can be not yet peristent, in this case
            its forced to become persistent by assigning OID to it.
            </param>
            <param name="mask">bit mask associated with this objects</param>
        </member>
        <member name="M:Perst.BitIndex.Remove(System.Object)">
            <summary>
            Remove object from the index 
            </summary>
            <param name="obj">object removed from the index
            </param>
            <returns><b>true</b> if member was successfully removed or <b>false</b> if member is not found</returns>
        </member>
        <member name="M:Perst.BitIndex.Size">
            <summary> Get number of objects in the index
            </summary>
            <returns>number of objects in the index
            
            </returns>
        </member>
        <member name="M:Perst.BitIndex.GetEnumerator(System.Int32,System.Int32)">
            <summary>
            Get enumerator for selecting objects with specified properties.
            </summary>
            <param name="setBits">bitmask specifying bits which should be set (1)</param>
            <param name="clearBits">bitmask specifying bits which should be cleared (0)</param>
            <returns>enumerator</returns>
        </member>
        <member name="M:Perst.BitIndex.Select(System.Int32,System.Int32)">
            <summary>
            Get enumerable collection for selecting objects with specified properties.
            </summary>
            <param name="setBits">bitmask specifying bits which should be set (1)</param>
            <param name="clearBits">bitmask specifying bits which should be cleared (0)</param>
            <returns>enumerable collection</returns>
        </member>
        <member name="P:Perst.BitIndex.Item(System.Object)">
            <summary> Access object bitmask
            </summary>
        </member>
        <member name="T:Perst.GenericPArray">
            <summary>
            Common interface for all PArrays
            </summary> 
        </member>
        <member name="M:Perst.GenericPArray.Size">
            <summary> Get number of the array elements
            </summary>
            <returns>the number of related objects
            
            </returns>
        </member>
        <member name="M:Perst.GenericPArray.GetOid(System.Int32)">
            <summary> Get OID of array element.
            </summary>
            <param name="i">index of the object in the relation
            </param>
            <returns>OID of the object (0 if array contains <b>null</b> reference)
            </returns>
        </member>
        <member name="M:Perst.GenericPArray.SetOwner(System.Object)">
            <summary>
            Set owner objeet for this PArray. Owner is persistent object contaning this PArray.
            This method is mostly used by storage itself, but can also used explicityl by programmer if
            Parray component of one persistent object is assigned to component of another persistent object
            </summary>
            <param name="owner">Link owner</param>
        </member>
        <member name="T:Perst.PArray">
            <summary>Dynamically extended array of reference to persistent objects.
            It is inteded to be used in classes using virtual properties to 
            access components of persistent objects. You can not use standard
            C# array here, instead you should use PArray class.
            PArray is created by Storage.createArray method
            </summary>
        </member>
        <member name="T:Perst.IPersistentMap">
            <summary>
             Interface for persistent dictionary.
             </summary>
        </member>
        <member name="F:Perst.Impl.PersistentListImpl.TreePosition.page">
            B-Tree page where element is located
        </member>
        <member name="F:Perst.Impl.PersistentListImpl.TreePosition.index">
            Index of first element at the page
        </member>
        <member name="T:Perst.IFile">
            <summary> Interface of file.
            Prorgemmer can provide its own impleentation of this interface, adding such features
            as support of flash cards, encrypted files,...
            Implentation of this interface should throw StorageError exception in case of failure
            </summary>
        </member>
        <member name="M:Perst.IFile.Write(System.Int64,System.Byte[])">
            <summary> Write data to the file
            </summary>
            <param name="pos"> offset in the file
            </param>
            <param name="buf"> array with data to be writter (size is always equal to database page size)
            </param>
            
        </member>
        <member name="M:Perst.IFile.Read(System.Int64,System.Byte[])">
            <summary> Reade data from the file
            </summary>
            <param name="pos"> offset in the file
            </param>
            <param name="buf"> array to receive readen data (size is always equal to database page size)
            </param>
            <returns> param number of bytes actually readen
            </returns>
        </member>
        <member name="M:Perst.IFile.Sync">
            <summary> Flush all fiels changes to the disk
            </summary>
        </member>
        <member name="M:Perst.IFile.Lock(System.Boolean)">
            <summary>
            Prevent other processes from modifying the file
            </summary>
            <param name="shared">true: shared lock, false: exclusive</param>
        </member>
        <member name="M:Perst.IFile.Unlock">
            <summary>
            Unlock file
            </summary>
        </member>
        <member name="M:Perst.IFile.Close">
            <summary> Close file
            </summary>
        </member>
        <member name="P:Perst.IFile.NoFlush">
            <summary>
            Boolean property. Set to <c>true</c> to avoid flushing the stream, or <c>false</c> to flush the stream with every calls to <see cref="M:Perst.IFile.Sync"/>
            </summary>
        </member>
        <member name="P:Perst.IFile.Length">
            <summary>
            Length of the file
            </summary>
            <returns>length of file in bytes</returns>
        </member>
        <member name="T:Perst.ObjectReader">
            <summary>
            Reader allowing to deserialize persistent object components
            </summary>
        </member>
        <member name="M:Perst.ObjectReader.ReadObject">
            <summary>
            Deserialize reference to persistent object
            </summary>
        </member>
        <member name="T:Perst.ObjectWriter">
            <summary>
            Writer allowing to serialize persistent object components
            </summary>
        </member>
        <member name="M:Perst.ObjectWriter.WriteObject(System.Object)">
            <summary>
            Serialize reference to persistent object
            </summary>
        </member>
        <member name="T:Perst.Enumerable">
            <summary>
            Helper class for working with enumerable returned by Query, Database and GenericIndex search methods 
            </summary>
        </member>
        <member name="M:Perst.Enumerable.First(System.Collections.IEnumerable)">
            <summary>
            Get first selected object. This methos can be used when single selected object is needed.
            Please notive, that this method doesn't check if selection contain more than one object
            </summary>
            <param name="enumerable">selection</param>
            <returns>first selected object or null if selection is empty</returns>
                    
        </member>
        <member name="M:Perst.Enumerable.ToArray(System.Collections.IEnumerable)">
            <summary>
            Convert selection to array 
            </summary>
            <param name="enumerable">selection</param>
            <returns>array with the selected objects</returns>
            
        </member>
        <member name="M:Perst.Enumerable.Count(System.Collections.IEnumerable)">
            <summary>
            Get number of selected objects         
            </summary>
            <param name="enumerable">selection</param>
            <returns>selection size</returns>
            
        </member>
        <member name="T:Perst.ClassExtentLockType">
            <summary> 
            Class extent lock type for execution of preapred statements
            </summary> 
        </member>
        <member name="T:Perst.IndexProvider">
            <summary> 
            Interface used by Query to get index for the specified key
            </summary> 
        </member>
        <member name="M:Perst.IndexProvider.GetIndex(System.Type,System.String)">
            <summary> 
            Get index for the specified field of the class
            </summary> 
            <param name="type">class where index is located</param>
            <param name="key">field of the class</param>
            <returns>Index for this field or null if index doesn't exist</returns>
        </member>
        <member name="T:Perst.MemoryUsage">
            <summary>
            Information about memory usage for the correspondent class. 
            Instances of this class are created by Storage.getMemoryDump method.
            Size of internal database structures (object index,* memory allocation bitmap) is associated with 
            <see cref="T:Perst.Storage"/> class. Size of class descriptors  - with <see cref="T:System.Type"/> class.
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.type">
            <summary>
            Class of persistent object or Storage for database internal data
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.nInstances">
            <summary>
            Number of reachable instance of the particular class in the database.
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.totalSize">
            <summary>
            Total size of all reachable instances
            </summary>
        </member>
        <member name="F:Perst.MemoryUsage.allocatedSize">
            <summary>
            Real allocated size of all instances. Database allocates space for th objects using quantums,
            for example object wilth size 25 bytes will use 32 bytes in the storage.
            In item associated with Storage class this field contains size of all allocated
            space in the database (marked as used in bitmap) 
            </summary>
        </member>
        <member name="M:Perst.MemoryUsage.#ctor(System.Type)">
            <summary>
            MemoryUsage constructor
            </summary>
        </member>
        <member name="T:Perst.Impl.AsyncReplicationMasterFile">
            <summary>
            File performing asynchronous replication of changed pages to specified slave nodes.
            </summary>
        </member>
        <member name="T:Perst.Impl.ReplicationMasterFile">
            <summary>
            File performing replication of changed pages to specified slave nodes.
            </summary>
        </member>
        <member name="M:Perst.Impl.ReplicationMasterFile.#ctor(Perst.Impl.ReplicationMasterStorageImpl,Perst.IFile)">
            <summary>
            Constructor of replication master file
            </summary>
            <param name="storage">replication storage</param>
            <param name="file">local file used to store data locally</param>
        </member>
        <member name="M:Perst.Impl.ReplicationMasterFile.#ctor(Perst.IFile,System.String[],System.Boolean)">
            <summary>
            Constructor of replication master file
            </summary>
            <param name="file">local file used to store data locally</param>
            <param name="hosts">slave node hosts to which replicastion will be performed</param>
            <param name="ack">whether master should wait acknowledgment from slave node during trasanction commit</param>
        </member>
        <member name="M:Perst.Impl.ReplicationMasterFile.HandleError(System.String)">
            <summary>
            When overriden by base class this method perfroms socket error handling
            </summary>     
            <returns><b>true</b> if host should be reconnected and attempt to send data to it should be 
            repeated, <b>false</b> if no more attmpts to communicate with this host should be performed 
            </returns>
        </member>
        <member name="M:Perst.Impl.AsyncReplicationMasterFile.#ctor(Perst.Impl.ReplicationMasterStorageImpl,Perst.IFile,System.Int32)">
            <summary>
            Constructor of replication master file
            <param name="storage">replication storage</param>
            <param name="file">local file used to store data locally</param>
            <param name="asyncBufSize">size of asynchronous buffer</param>
            </summary>
        </member>
        <member name="M:Perst.Impl.AsyncReplicationMasterFile.#ctor(Perst.IFile,System.String[],System.Int32,System.Boolean)">
            <summary>
            Constructor of replication master file
            <param name="file">local file used to store data locally</param>
            <param name="hosts">slave node hosts to which replicastion will be performed</param>
            <param name="asyncBufSize">size of asynchronous buffer</param>
            <param name="ack">whether master should wait acknowledgment from slave node during trasanction commit</param>
            </summary>
        </member>
        <member name="T:Perst.Resolver">
            <summary> Abstraction of class resolver.
            Resolver can be used to replaced SQL JOINs: given object ID, 
            it will provide reference to the resolved object
            </summary>
        </member>
        <member name="M:Perst.Resolver.Resolve(System.Object)">
            <summary> Resolve object
            </summary>
            <param name="obj">original object to be resolved
            </param>
            <returns> resolved object
            </returns>
        </member>
        <member name="T:Perst.PersistentString">
            <summary>
            Class encapsulating native .Net string. System.String is not persistent object
            so it can not be stored in Perst as independent persistent object. 
            But sometimes it is needed. This class sole this problem providing implcit conversion
            operator from System.String to PerisstentString.
            Also PersistentString class is mutable, allowing to change it's values.
            </summary>
        </member>
        <member name="M:Perst.PersistentString.#ctor(System.String)">
            <summary>
            Consutrctor of perisstent string
            </summary>
            <param name="str">.Net string</param>
        </member>
        <member name="M:Perst.PersistentString.ToString">
            <summary>
            Get .Net string
            </summary>
            <returns>.Net string</returns>
        </member>
        <member name="M:Perst.PersistentString.Append(System.String)">
            <summary>
            Append string to the current string value of PersistentString
            </summary>
            <param name="tail">appended string</param>
        </member>
        <member name="M:Perst.PersistentString.Set(System.String)">
            <summary>
            Assign new string value to the PersistentString
            </summary>
            <param name="str">new string value</param>
        </member>
        <member name="M:Perst.PersistentString.Get">
            <summary>
            Get current string value
            </summary>
            <returns>.Net string</returns>
        </member>
        <member name="M:Perst.PersistentString.op_Implicit(System.String)~Perst.PersistentString">
            <summary>
            Operator for implicit convertsion from System.String to PersistentString
            </summary>
            <param name="str">.Net string</param>
            <returns>PersistentString</returns>
        </member>
        <member name="M:Perst.PersistentString.op_Implicit(Perst.PersistentString)~System.String">
            <summary>
            Operator for implicit convertsion from PersistentString to System.String
            </summary>
            <param name="str">PersistentString</param>
            <returns>.Net string</returns>
        </member>
        <member name="T:Perst.MultidimensionalComparator">
            <summary> 
            Base class for multidimensional persistent comparator used in multidimensional index
            </summary>
        </member>
        <member name="M:Perst.MultidimensionalComparator.Compare(System.Object,System.Object,System.Int32)">
            <summary>
            Compare  i-th component of two objects
            </summary>
            <param name="m1">first object</param>
            <param name="m2">second object</param>
            <param name="i">component index</param>
            <returns>LEFT_UNDEFINED if value of i-th component of m1 is null and 
            value  of i-th component of m2 is not null, 
            RIGHT_UNDEFINED if value of i-th component of m1 is not null and 
            value  of i-th component of m2 is null, 
            EQ if both values are null,
            otherwise LT, EQ or GT depending on result of their comparison
            </returns>
        </member>
        <member name="M:Perst.MultidimensionalComparator.CloneField(System.Object,System.Int32)">
            <summary>
            Create clone of the specified object contining copy of the specified field
            </summary>
            <param name="obj">original object</param>
            <param name="i">component index</param>
            <returns>clone of the object
            </returns>
        </member>
        <member name="P:Perst.MultidimensionalComparator.NumberOfDimensions">
            <summary>
            Get number of dimensions
            </summary>
            <returns>number of dimensions
            </returns>
        </member>
        <member name="T:Perst.PatriciaTrie">
            <summary> 
            PATRICIA trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric).
            Tries are a kind of tree where each node holds a common part of one or more keys. 
            PATRICIA trie is one of the many existing variants of the trie, which adds path compression 
            by grouping common sequences of nodes together.
            This structure provides a very efficient way of storing values while maintaining the lookup time 
            for a key in O(N) in the worst case, where N is the length of the longest key. 
            This structure has it's main use in IP routing software, but can provide an interesting alternative 
            to other structures such as hashtables when memory space is of concern.
            </summary>
        </member>
        <member name="M:Perst.PatriciaTrie.Add(Perst.PatriciaTrieKey,System.Object)">
             <summary> 
             Add new key to the trie
             </summary>
             <param name="key">bit vector</param>
             <param name="obj">persistent object associated with this key</param>
             <returns>previous object associtated with this key or <b>null</b> if there
             was no such object</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.FindBestMatch(Perst.PatriciaTrieKey)">
             <summary>
             Find best match with specified key
             </summary>
             <param name="key">bit vector</param>
             <returns>object associated with this deepest possible match with specified key</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.FindExactMatch(Perst.PatriciaTrieKey)">
             <summary>
             Find exact match with specified key
             </summary>
             <param name="key">bit vector</param>
             <returns>object associated with this key or NULL if match is not found</returns>
            
        </member>
        <member name="M:Perst.PatriciaTrie.Remove(Perst.PatriciaTrieKey)">
             <summary>
             Removes key from the triesKFind exact match with specified key
             </summary>
             <param name="key">bit vector</param>
             <returns>object associated with removed key or <b>null</b> if such key is not found</returns>
            
        </member>
        <member name="T:Perst.Version">
            <summary> Base class for version of versioned object. All versions are kept in version history.
            </summary>
        </member>
        <member name="M:Perst.Version.NewVersion">
            <summary> Create new version which will be direct successor of this version.
            This version has to be checked-in in order to be placed in version history.
            </summary>
        </member>
        <member name="M:Perst.Version.CheckIn">
            <summary> Check-in new version. This method inserts in version history version created by 
            <b>Version.newVersion</b> or <b>VersionHistory.checkout</b> method
            </summary>
        </member>
        <member name="M:Perst.Version.AddPredecessor(Perst.Version)">
            <summary> Make specified version predecessor of this version. 
            This method can be used to perfrom merge of two versions (merging of version data 
            should be done by application itself)
            </summary>
            <param name="predecessor">version to merged with
            
            </param>
        </member>
        <member name="M:Perst.Version.AddLabel(System.String)">
            <summary> Add new label to this version
            </summary>
            <param name="label">label to be associated with this version
            
            </param>
        </member>
        <member name="M:Perst.Version.HasLabel(System.String)">
            <summary> Check if version has specified label
            </summary>
            <param name="label">version label
            
            </param>
        </member>
        <member name="M:Perst.Version.#ctor(Perst.Storage)">
            <summary> Constructor of roto version. All other versions should be created using 
            <b>Version.newVersion</b> or <b>VersionHistory.checkout</b> method
            </summary>
        </member>
        <member name="M:Perst.Version.#ctor">
            <summary> Default constuctor. No directly accessible.
            </summary>
        </member>
        <member name="P:Perst.Version.VersionHistory">
            <summary> Get version history containing this versioned object
            </summary>
        </member>
        <member name="P:Perst.Version.Predecessors">
            <summary> Get predecessors of this version
            </summary>
            <returns> array of predecessor versions
            
            </returns>
        </member>
        <member name="P:Perst.Version.Successors">
            <summary> Get successors of this version
            </summary>
            <returns> array of predecessor versions
            
            </returns>
        </member>
        <member name="P:Perst.Version.IsCheckedIn">
            <summary> Check if version is checked-in
            </summary>
            <returns> <b>true</b> if version belongs to version history
            
            </returns>
        </member>
        <member name="P:Perst.Version.IsCheckedOut">
            <summary> Check if version is checked-out
            </summary>
            <returns> <b>true</b> if version is just created and not checked-in yet 
            (and so belongs to version history)
            
            </returns>
        </member>
        <member name="P:Perst.Version.Date">
            <summary> Get date of version creation 
            </summary>
            <returns> date when this version was created
            
            </returns>
        </member>
        <member name="P:Perst.Version.Labels">
            <summary> Get labels associated with this version
            </summary>
            <returns> array of labels assigned to this version 
            
            </returns>
        </member>
        <member name="P:Perst.Version.Id">
            <summary> Get identifier of the version 
            </summary>
            <returns> version identifier  automatically assigned by system
            
            </returns>
        </member>
        <member name="T:Perst.PersistentContext">
            <summary>Base class for context bound object with provided
            transparent persistence. Objects derived from this class and marked with
            TransparentPresistence attribute automatically on demand load their 
            content from the database and also automatically detect object modification.
            </summary>
        </member>
        <member name="T:Perst.NullFile">
            <summary>
            This implementation of <see cref="T:Perst.NullFile"/> interface can be used
            to make Perst an main-memory database. It should be used when pagePoolSize
            is set to 0. In this case all pages are cached in memory
            and <see cref="T:Perst.NullFile"/> is used just as a stub.
            <see cref="T:Perst.NullFile"/> should be used only when data is transient - i.e. it should not be saved
            between database sessions. If you need in-memory database but which provide data persistency, 
            you should use normal file and infinite page pool size. 
            </summary>
        </member>
        <member name="T:Perst.IndexableAttribute">
            <summary>
            Attribute for marking indexable fields used by Database class to create table descriptors. 
            Indices can be unique or allow duplicates.
            If index is marked as unique and during transaction commit it is find out that there is already some other object
            with this key, NotUniqueException will be thrown
            Case insensitive attribute is meaningful only for string keys and if set cause ignoring case
            of key values.
            </summary>
        </member>
        <member name="T:Perst.CompoundIndex">
            <summary> Interface of compound index. 
            </summary>
        </member>
        <member name="P:Perst.CompoundIndex.KeyTypes">
            <summary>
            Get types of compund key components
            </summary>
            <returns>array of types of compund key componentss</returns>
        </member>
        <member name="T:Perst.CompressedFile">
            
             <summary>
             Compressed read-write database file. 
             To work with compressed database file you should pass instance of this class in <code>Storage.Open</code> method
             </summary>
            
        </member>
        <member name="M:Perst.CompressedFile.#ctor(System.String)">
            
             <summary>
             Constructor of compressed file with default parameter values
             </summary>
             <param name="dataFilePath">path to the data file</param> 
            
        </member>
        <member name="M:Perst.CompressedFile.#ctor(System.String,System.String)">
            
             <summary>
             Constructor of compressed file with default parameter values
             </summary>
             <param name="dataFilePath">path to the data file</param> 
             <param name="cipherKey">cipher key (if null, then no encryption is performed)</param> 
            
        </member>
        <member name="M:Perst.CompressedFile.#ctor(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Int64)">
            
             <summary>
             Constructor of compressed file
             </summary>
             <param name="dataFilePath">path to the data file</param> 
             <param name="cipherKey">cipher key (if null, then no encryption is performed)</param> 
             <param name="indexFilePath">path to the index file</param> 
             <param name="readOnly">whether access to the file is read-only</param> 
             <param name="noFlush">whether synchronous write to the disk should be performed</param> 
             <param name="dataFileExtensionQuantum">quantum of extending data file</param>
            
        </member>
        <member name="T:Perst.RectangleR2">
            <summary>
            R2 rectangle class. This class is used in spatial index.
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.Area">
            <summary>
            Rectangle area
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.JoinArea(Perst.RectangleR2,Perst.RectangleR2)">
            <summary>
            Area of covered rectangle for two sepcified rectangles
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.#ctor(Perst.RectangleR2)">
            <summary>
            Create copy of the rectangle
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Construct rectangle with specified coordinates
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.Join(Perst.RectangleR2)">
            <summary>
            Join two rectangles. This rectangle is updates to contain cover of this and specified rectangle.
            </summary>
            <param name="r">rectangle to be joined with this rectangle
            </param>
        </member>
        <member name="M:Perst.RectangleR2.Join(Perst.RectangleR2,Perst.RectangleR2)">
            <summary>
             Non destructive join of two rectangles. 
            </summary>
            <param name="a">first joined rectangle
            </param>
            <param name="b">second joined rectangle
            </param>
            <returns>rectangle containing cover of these two rectangles
            </returns>
        </member>
        <member name="M:Perst.RectangleR2.Intersects(Perst.RectangleR2)">
            <summary>
            Checks if this rectangle intersects with specified rectangle
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.Contains(Perst.RectangleR2)">
            <summary>
            Checks if this rectangle contains the specified rectangle
            </summary>
        </member>
        <member name="M:Perst.RectangleR2.IsEmpty">
            <summary>
            Check if rectanlge is empty 
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Top">
            <summary>
            Smallest Y coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Left">
            <summary>
            Smallest X coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Bottom">
            <summary>
            Greatest Y coordinate  of the rectangle
            </summary>
        </member>
        <member name="P:Perst.RectangleR2.Right">
            <summary>
            Greatest X coordinate  of the rectangle
            </summary>
        </member>
        <member name="T:Perst.Storage">
            <summary> Object storage
            </summary>
        </member>
        <member name="M:Perst.Storage.Open(System.String,System.Int64)">
            <summary> Open the storage
            </summary>
            <param name="filePath">path to the database file
            </param>
            <param name="pagePoolSize">size of page pool (in bytes). Page pool should contain
            at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
            But larger page pool ussually leads to better performance (unless it could not fit
            in memory and cause swapping). If value of pagePoolSize is 0, then page pool will be
            unlimited - dynamically extended to conatins all database file pages.
            </param>
        </member>
        <member name="M:Perst.Storage.Open(System.String)">
            <summary> Open the storage with default page pool size
            </summary>
            <param name="filePath">path to the database file
            
            </param>
        </member>
        <member name="M:Perst.Storage.Open(Perst.IFile,System.Int64)">
            <summary> Open the storage
            </summary>
            <param name="file">user specific implementation of IFile interface
            </param>
            <param name="pagePoolSize">size of page pool (in bytes). Page pool should contain
            at least ten 4kb pages, so minimal page pool size should be at least 40Kb.
            But larger page pool ussually leads to better performance (unless it could not fit
            in memory and cause swapping).
            
            </param>
        </member>
        <member name="M:Perst.Storage.Open(Perst.IFile)">
            <summary> Open the storage with default page pool size
            </summary>
            <param name="file">user specific implementation of IFile interface
            </param>
        </member>
        <member name="M:Perst.Storage.Open(System.String,System.Int64,System.String)">
            <summary> Open the encrypted storage
            </summary>
            <param name="filePath">path to the database file
            </param>
            <param name="pagePoolSize">size of page pool (in bytes). Page pool should contain
            at least then 4kb pages, so minimal page pool size should be at least 40Kb.
            But larger page pool usually leads to better performance (unless it could not fit
            in memory and cause swapping).
            </param>
            <param name="cipherKey">cipher key</param>
        </member>
        <member name="M:Perst.Storage.IsOpened">
            <summary>Check if database is opened
            </summary>
            <returns><b>true</b> if database was opened by <b>open</b> method, 
            <b>false</b> otherwise
            </returns>        
        </member>
        <member name="M:Perst.Storage.Commit">
            <summary> Commit changes done by the last transaction. Transaction is started implcitlely with forst update
            opertation.
            </summary>
        </member>
        <member name="M:Perst.Storage.Rollback">
            <summary> Rollback changes made by the last transaction
            </summary>
        </member>
        <member name="M:Perst.Storage.Backup(System.IO.Stream)">
            <summary>
            Backup current state of database
            </summary>
            <param name="stream">output stream to which backup is done</param>
        </member>
        <member name="M:Perst.Storage.CreateQuery">
            <summary> Create JSQL query. JSQL is object oriented subset of SQL allowing
            to specify arbitrary prdicates for selecting members of Perst collections
            </summary>
            <returns> created query object
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateIndex(System.Type,System.Boolean)">
            <summary> Create new index
            </summary>
            <param name="type">type of the index key (you should path here <b>String.class</b>, 
            <b>int.class</b>, ...)
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.UNSUPPORTED_INDEX_TYPE) exception if 
            specified key type is not supported by implementation.
            
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateIndex(System.Type[],System.Boolean)">
            <summary> Create new compound index.
            </summary>
            <param name="types">types of components of compund key
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.UNSUPPORTED_INDEX_TYPE) exception if 
            specified key type is not supported by implementation.
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateMultidimensionalIndex(Perst.MultidimensionalComparator)">
            <summary>
            Create new multidimensional index
            </summary>
            <param name="comparator">multidimensinal comparator</param>
            <returns>multidimensional index</returns>
        </member>
        <member name="M:Perst.Storage.CreateMultidimensionalIndex(System.Type,System.String[],System.Boolean)">
            <summary>
            Create new multidimensional index for specified fields of the class 
            </summary>
            <param name="type">class of objects included in this index</param>
            <param name="fieldNames">name of the fields which are treated as index dimensions,
            if null then all declared fields of the class are used.</param>
            <param name="treateZeroAsUndefinedValue">if value of scalar field in QBE object is 0 
            (default value) then assume that condition is not defined for this field</param>
            <returns>multidimensional index</returns>
        </member>
        <member name="M:Perst.Storage.CreateThickIndex(System.Type)">
            <summary> Create new thick index (index with large number of duplicated keys)
            </summary>
            <param name="type">type of the index key (you should path here <b>String.class</b>, 
            <b>int.class</b>, ...)
            </param>
            <returns>persistent object implementing thick index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.UNSUPPORTED_INDEX_TYPE) exception if 
            specified key type is not supported by implementation.
            
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateFieldIndex(System.Type,System.String,System.Boolean)">
            <summary> 
            Create new field index
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldName">name of the index field. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateFieldIndex(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary> 
            Create new field index
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldName">name of the index field. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <param name="caseInsensitive">whether index is case insinsitive (ignored for non-string keys)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateFieldIndex(System.Type,System.String[],System.Boolean)">
            <summary> 
            Create new multi-field index
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldNames">array of names of the fields. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateFieldIndex(System.Type,System.String[],System.Boolean,System.Boolean)">
            <summary> 
            Create new multi-field index
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldNames">array of names of the fields. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <param name="caseInsensitive">whether index is case insinsitive (ignored for non-string keys)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateRandomAccessIndex(System.Type,System.Boolean)">
            <summary> Create new index optimized for access by element position. 
            </summary>
            <param name="type">type of the index key (you should path here <b>String.class</b>, 
            <b>int.class</b>, ...)
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.UNSUPPORTED_INDEX_TYPE) exception if 
            specified key type is not supported by implementation.
            
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateRandomAccessIndex(System.Type[],System.Boolean)">
            <summary> Create new compound index optimized for access by element position.
            </summary>
            <param name="types">types of components of compund key
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorCode.UNSUPPORTED_INDEX_TYPE) exception if 
            specified key type is not supported by implementation.
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateRandomAccessFieldIndex(System.Type,System.String,System.Boolean)">
            <summary> 
            Create new field index optimized for access by element position.
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldName">name of the index field. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateRandomAccessFieldIndex(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary> 
            Create new field index optimized for access by element position.
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldName">name of the index field. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <param name="caseInsensitive">whether index is case insinsitive (ignored for non-string keys)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateRandomAccessFieldIndex(System.Type,System.String[],System.Boolean)">
            <summary> 
            Create new multi-field index optimized for access by element position.
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldNames">array of names of the fields. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateRandomAccessFieldIndex(System.Type,System.String[],System.Boolean,System.Boolean)">
            <summary> 
            Create new multi-field index optimized for access by element position.
            </summary>
            <param name="type">objects of which type (or derived from which type) will be included in the index
            </param>
            <param name="fieldNames">array of names of the fields. Field with such name should be present in specified class <b>type</b>
            </param>
            <param name="unique">whether index is unique (duplicate value of keys are not allowed)
            </param>
            <param name="caseInsensitive">whether index is case insinsitive (ignored for non-string keys)
            </param>
            <returns>persistent object implementing field index
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.INDEXED_FIELD_NOT_FOUND) if there is no such field in specified class,
            StorageError(StorageError.UNSUPPORTED_INDEX_TYPE) exception if type of specified field is not supported by implementation
            </exception>
        </member>
        <member name="M:Perst.Storage.CreateBitIndex">
            <summary>
            Create new bit index. Bit index is used to select object 
            with specified set of (boolean) properties.
            </summary>
            <returns>persistent object implementing bit index</returns>
        </member>
        <member name="M:Perst.Storage.CreateSpatialIndex">
            <summary>
            Create new spatial index with integer coordinates
            </summary>
            <returns>
            persistent object implementing spatial index
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateSpatialIndexR2">
            <summary>
            Create new R2 spatial index
            </summary>
            <returns>
            persistent object implementing spatial index
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateSortedCollection(Perst.PersistentComparator,System.Boolean)">
            <summary>
            Create new sorted collection with specified comparator
            </summary>
            <param name="comparator">comparator class specifying order in the collection</param>
            <param name="unique"> whether collection is unique (members with the same key value are not allowed)</param>
            <returns> persistent object implementing sorted collection</returns>
        </member>
        <member name="M:Perst.Storage.CreateSortedCollection(System.Boolean)">
            <summary>
            Create new sorted collection. Members of this collections should implement 
            <b>System.IComparable</b> interface and make it possible to compare 
            collection members with each other as well as with serch key.
            </summary>
            <param name="unique"> whether collection is unique (members with the same key value are not allowed)</param>
            <returns> persistent object implementing sorted collection</returns>
        </member>
        <member name="M:Perst.Storage.CreateSet">
            <summary>
            Create new object set
            </summary>
            <returns>
            empty set of persistent objects
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateLink">
            <summary> Create one-to-many link.
            </summary>
            <returns>new empty link, new members can be added to the link later.
            
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateLink(System.Int32)">
            <summary> Create one-to-many link with specified initial size.
            </summary>
            <param name="initialSize">initial size of the array</param>
            <returns>new link with specified size
            
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateScalableSet">
            <summary>  Create new scalable set references to persistent objects.
            This container can efficiently store small number of references as well 
            as very large number references. When number of members is small, 
            Link class is used to store set members. When number of members exceed 
            some threshold, PersistentSet (based on B-Tree) is used instead.
            </summary>
            <returns>new empty set, new members can be added to the set later.
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateScalableSet(System.Int32)">
            <summary>  Create new scalable set references to persistent objects.
            This container can efficiently store small number of references as well 
            as very large number references. When number of members is small, 
            Link class is used to store set members. When number of members exceed 
            some threshold, PersistentSet (based on B-Tree) is used instead.
            </summary>
            <param name="initialSize">initial size of the sety</param>
            <returns>new empty set, new members can be added to the set later.
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateList">
             <summary>
             Create new peristent list. Implementation of this list is based on B-Tree so it can efficiently
             handle large number of objects but in case of very small list memory overhead is too high.
             </summary>
             <returns>persistent object implementing list</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateScalableList">
             <summary>
             Create new scalable list of persistent objects.
             This container can efficiently handle small lists as well as large lists                                                                          
             When number of members is small, Link class is used to store set members.
             When number of members exceeds some threshold, PersistentList (based on B-Tree)                                                                                                                     
             is used instead.
             </summary>
             <returns>scalable set implementation</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateScalableList(System.Int32)">
             <summary>
             Create new scalable list of persistent objects.
             This container can efficiently handle small lists as well as large lists 
             When number of members is small, Link class is used to store set members.
             When number of members exceeds some threshold, PersistentList (based on B-Tree)
             is used instead.
             </summary>
             <param name="initialSize">initial size of the list</param>
             <returns>scalable set implementation</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateHash">
             <summary>
             Create hierarhical hash table. Levels of tree are added on demand.
             </summary>
             <returns>scalable persistent map implementation</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateHash(System.Int32,System.Int32)">
             <summary>
             Create hierarhical hash table. Levels of tree are added on demand.
             </summary>
             <param name="pageSize">Number of elements in hash tree node</param>
             <param name="loadFactor">Maximal collision chain lengthe</param>
             <returns>scalable persistent map implementation</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateMap(System.Type)">
             <summary>
             Create scalable persistent map.
             This container can efficiently handle both small and large number of members.
             For small maps, implementation  uses sorted array. For large maps - B-Tree.
             </summary>
             <param name="keyType">Type of map key</param>
             <returns>scalable persistent map implementation</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateMap(System.Type,System.Int32)">
             <summary>
             Create scalable persistent map.
             This container can efficiently handle both small and large number of members.
             For small maps, implementation  uses sorted array. For large maps - B-Tree.
             </summary>
             <param name="keyType">Type of map key</param>
             <param name="initialSize">initial size of the list</param>
             <returns>scalable persistent map implementation</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateArray">
            <summary> Create dynamcially extended array of reference to persistent objects.
            It is inteded to be used in classes using virtual properties to 
            access components of persistent objects.  
            </summary>
            <returns>new empty array, new members can be added to the array later.
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateArray(System.Int32)">
            <summary> Create dynamcially extended array of reference to persistent objects.
            It is inteded to be used in classes using virtual properties to 
            access components of persistent objects.  
            </summary>
            <param name="initialSize">initially allocated size of the array</param>
            <returns>new empty array, new members can be added to the array later.
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateRelation(System.Object)">
            <summary> Create relation object. Unlike link which represent embedded relation and stored
            inside owner object, this Relation object is standalone persisitent object
            containing references to owner and members of the relation
            </summary>
            <param name="owner">owner of the relation
            </param>
            <returns>object representing empty relation (relation with specified owner and no members), 
            new members can be added to the link later.
            
            </returns>
        </member>
        <member name="M:Perst.Storage.CreateBlob">
            <summary>
            Create new BLOB. Create object for storing large binary data.
            </summary>
            <returns>empty BLOB</returns>
        </member>
        <member name="M:Perst.Storage.CreateFullTextIndex(Perst.FullText.FullTextSearchHelper)">
             <summary>
             Create full text search index
             </summary>
             <param name="helper">helper class which provides method for scanning, stemming and tuning query</param>
             <returns>full text search index</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateFullTextIndex">
            
             Create full text search index with default helper
             <returns>full text search index</returns>
            
        </member>
        <member name="M:Perst.Storage.CreateTimeSeries(System.Type,System.Int64)">
            <summary>
            Create new time series object. 
            </summary>
            <param name="blockClass">class derived from TimeSeriesBlock</param>
            <param name="maxBlockTimeInterval">maximal difference in system ticks (100 nanoseconds) between timestamps 
            of the first and the last elements in a block. 
            If value of this parameter is too small, then most blocks will contains less elements 
            than preallocated. 
            If it is too large, then searching of block will be inefficient, because index search 
            will select a lot of extra blocks which do not contain any element from the 
            specified range.
            Usually the value of this parameter should be set as
            (number of elements in block)*(tick interval)*2. 
            Coefficient 2 here is used to compencate possible holes in time series.
            For example, if we collect stocks data, we will have data only for working hours.
            If number of element in block is 100, time series period is 1 day, then
            value of maxBlockTimeInterval can be set as 100*(24*60*60*10000000L)*2
            </param>
            <returns>new empty time series</returns>
        </member>
        <member name="M:Perst.Storage.CreatePatriciaTrie">
             <summary>
             Create PATRICIA trie (Practical Algorithm To Retrieve Information Coded In Alphanumeric)
             Tries are a kind of tree where each node holds a common part of one or more keys. 
             PATRICIA trie is one of the many existing variants of the trie, which adds path compression 
             by grouping common sequences of nodes together.
             This structure provides a very efficient way of storing values while maintaining the lookup time 
             for a key in O(N) in the worst case, where N is the length of the longest key. 
             This structure has it's main use in IP routing software, but can provide an interesting alternative 
             to other structures such as hashtables when memory space is of concern.
             </summary>
             <returns>created PATRICIA trie</returns>
            
        </member>
        <member name="M:Perst.Storage.Close">
            <summary> Commit transaction (if needed) and close the storage
            </summary>
        </member>
        <member name="M:Perst.Storage.SetGcThreshold(System.Int64)">
             <summary> Set threshold for initiation of garbage collection. By default garbage collection is disable (threshold is set to
             Int64.MaxValue). If it is set to the value different fro Long.MAX_VALUE, GC will be started each time when
             delta between total size of allocated and deallocated objects exceeds specified threashold OR
             after reaching end of allocation bitmap in allocator. 
             </summary>
             <param name="allocatedDelta"> delta between total size of allocated and deallocated object since last GC or storage opening
             </param>
            
        </member>
        <member name="M:Perst.Storage.Gc">
            <summary>Explicit start of garbage collector
            </summary>
            <returns>number of collected (deallocated) objects</returns>
            
        </member>
        <member name="M:Perst.Storage.ExportXML(System.IO.StreamWriter)">
            <summary> Export database in XML format 
            </summary>
            <param name="writer">writer for generated XML document
            
            </param>
        </member>
        <member name="M:Perst.Storage.ImportXML(System.IO.TextReader)">
            <summary> Import data from XML file
            </summary>
            <param name="reader">XML document reader
            
            </param>
        </member>
        <member name="M:Perst.Storage.GetObjectByOID(System.Int32)">
            <summary> 
            Retrieve object by OID. This method should be used with care because
            if object is deallocated, its OID can be reused. In this case
            getObjectByOID will return reference to the new object with may be
            different type.
            </summary>
            <param name="oid">object oid</param>
            <returns>reference to the object with specified OID</returns>
        </member>
        <member name="M:Perst.Storage.MakePersistent(System.Object)">
            <summary> 
            Explicitely make object peristent. Usually objects are made persistent
            implicitlely using "persistency on reachability apporach", but this
            method allows to do it explicitly. If object is already persistent, execution of
            this method has no effect.
            </summary>
            <param name="obj">object to be made persistent</param>
            <returns>OID assigned to the object</returns>
        </member>
        <member name="M:Perst.Storage.SetProperty(System.String,System.Object)">
            
             <summary>
             Set database property. This method should be invoked before opening database. 
             </summary>
             <remarks> 
             Currently the following boolean properties are supported:
             <TABLE><TR><TH>Property name</TH><TH>Parameter type</TH><TH>Default value</TH><TH>Description</TH></TR>
             <TR><TD><b>perst.serialize.transient.objects</b></TD><TD>bool</TD><TD>false</TD>
             <TD>Serialize any class not derived from IPersistent or IValue using standard Java serialization
             mechanism. Packed object closure is stored in database as byte array. Latter the same mechanism is used
             to unpack the objects. To be able to use this mechanism, object and all objects referenced from it
             should be marked with Serializable attribute and should not contain references
             to persistent objects. If such object is referenced from N persistent object, N instances of this object
             will be stored in the database and after loading there will be N instances in memory.
             </TD></TR>
             <TR><TD><b>perst.object.cache.init.size</b></TD><TD>int</TD><TD>1319</TD>
             <TD>Initial size of object cache
             </TD></TR>
             <TR><TD><b>perst.object.cache.kind</b></TD><TD>String</TD><TD>"lru"</TD>
             <TD>Kind of object cache. The following values are supported:
             "strong", "weak", "pinned", "lru". <B>Strong</B> cache uses strong (normal)                                                                         
             references to refer persistent objects. Thus none of loaded persistent objects                                                                                                                                         
             can be deallocated by GC. It is possible to explicitely clear object cache using 
             <b>Storage.ClearObjectCache()</b> method. <B>Weak</B> and <b>lru</b> caches use weak references. 
             But <b>lru</b> cache also pin some number of recently used objects.
             Pinned object cache pin in memory all modified objects while using weak referenced for 
             non-modified objects. This kind of cache eliminate need in finalization mechanism - all modified
             objects are kept in memory and are flushed to the disk only at the end of transaction. 
             So the size of transaction is limited by amount of main memory. Non-modified objects are accessed only 
             through weak references so them are not protected from GC and can be thrown away.
             </TD></TR>
             <TR><TD><b>perst.object.index.init.size</b></TD><TD>int</TD><TD>1024</TD>
             <TD>Initial size of object index (specifying large value increase initial size of database, but reduce
             number of index reallocations)
             </TD></TR>
             <TR><TD><b>perst.extension.quantum</b></TD><TD>long</TD><TD>1048576</TD>
             <TD>Object allocation bitmap extension quantum. Memory is allocate by scanning bitmap. If there is no
             large enough hole, then database is extended by the value of dbDefaultExtensionQuantum. 
             This parameter should not be smaller than 64Kb.
             </TD></TR>
             <TR><TD><b>perst.gc.threshold</b></TD><TD>long</TD><TD>long.MaxValue</TD>
             <TD>Threshold for initiation of garbage collection. 
             If it is set to the value different from long.MaxValue, GC will be started each time 
             when delta between total size of allocated and deallocated objects exceeds specified threashold OR                                                                                                                                                                                                                           
             after reaching end of allocation bitmap in allocator.
             </TD></TR>
             <TR><TD><b>perst.code.generation</b></TD><TD>string</TD><TD>async</TD>
             <TD>enable or disable dynamic generation of pack/unpack methods for persistent 
             classes. Such methods can be generated only for classes with public fields.
             Using generated methods instead of .Net reflection API increase speed of
             object store/fetch operations, but generation itself takes additional time at 
             startup. This parameter can have three values: "sync", "async" (or "true") and 
             "disabled" (or "false"). In case of asynchronous methods generation,
             it is performed by background thread with low priority. It has minimal influence on
             database open time, but if large of the objects are loaded from the database
             immediately after database open, then pack.unpack methods may not be ready and
             so loading of database takes a longer time.
             Synchronous methods inside Storage.Open method. So it can increase time of 
             opening database (especially if there are large number of classes in database)
             but in this case all pack/unpack methods will be ready after return from Open method.
             If runtime code generation is disabled, then no methods are generated.
             Runtime code generation is not supported and so is disabled at Compact.Net platform.
             </TD></TR>
             <TR><TD><b>perst.file.readonly</b></TD><TD>bool</TD><TD>false</TD>
             <TD>Database file should be opened in read-only mode.
             </TD></TR>
             <TR><TD><b>perst.lock.file</b></TD><TD>bool</TD><TD>true</TD>
             <TD>Lock database file to prevent concurrent access to the database by 
              more than one application.
             </TD></TR>
             <TR><TD><b>perst.file.noflush</b></TD><TD>bool</TD><TD>false</TD>
             <TD>To not flush file during transaction commit. It will greatly increase performance because
             eliminate synchronous write to the disk (when program has to wait until all changed
             are actually written to the disk). But it can cause database corruption in case of 
             OS or power failure (but abnormal termination of application itself should not cause
             the problem, because all data which were written to the file, but is not yet saved to the disk is 
             stored in OS file buffers and sooner or later them will be written to the disk)
             </TD></TR>
             <TR><TD><b>perst.alternative.btree</b></TD><TD>bool</TD><TD>false</TD>
             <TD>Use aternative implementation of B-Tree (not using direct access to database
             file pages). This implementation should be used in case of serialized per thread transctions.
             New implementation of B-Tree will be used instead of old implementation
             if "perst.alternative.btree" property is set. New B-Tree has incompatible format with 
             old B-Tree, so you could not use old database or XML export file with new indices. 
             Alternative B-Tree is needed to provide serializable transaction (old one could not be used).
             Also it provides better performance (about 3 times comaring with old implementation) because
             of object caching. And B-Tree supports keys of user defined types. 
             </TD></TR>
             <TR><TD><b>perst.background.gc</b></TD><TD>bool</TD><TD>false</TD>
             <TD>Perform garbage collection in separate thread without blocking the main application.                                                                                          
             </TD></TR>
             <TR><TD><b>perst.string.encoding</b></TD><TD>String</TD><TD>null</TD>
             <TD>Specifies encoding of storing strings in the database. By default Perst stores 
             strings as sequence of chars (two bytes per char). If all strings in application are in 
             the same language, then using encoding  can significantly reduce space needed
             to store string (about two times). But please notice, that this option has influence
             on all strings  stored in database. So if you already have some data in the storage
             and then change encoding, then it can cause incorrect fetching of strings and even database crash.
             </TD></TR>
             <TR><TD><b>perst.replication.ack</b></TD><TD>Boolean</TD><TD>false</TD>
             <TD>Request acknowledgement from slave that it receives all data before transaction
             commit. If this option is not set, then replication master node just writes
             data to the socket not warring whether it reaches slave node or not.
             When this option is set to true, master not will wait during each transaction commit acknowledgement
             from slave node. Please notice that this option should be either set or not set both
             at slave and master node. If it is set only on one of this nodes then behavior of
             the system is unpredicted. This option can be used both in synchronous and asynchronous replication
             mode. The only difference is that in first case main application thread will be blocked waiting
             for acknowledgment, while in the asynchronous mode special replication thread will be blocked
             allowing thread performing commit to proceed.
             </TD></TR>
             <TR><TD><b>perst.concurrent.iterator</b></TD><TD>bool</TD><TD>false</TD>
             <TD>By default iterator will throw ConcurrentModificationException if iterated collection
             was changed outside iterator, when the value of this property is true then iterator will 
             try to restore current position and continue iteration
             </TD></TR>
             <TR><TD><b>perst.slave.connection.timeout</b></TD><TD>int</TD><TD>60</TD>
             <TD>Timeout in seconds during which mastr node will try to establish connection with slave node. 
             If connection can not be established within specified time, then master will not perform 
             replication to this slave node
             </TD></TR>
             <TR><TD><b>perst.page.pool.lru.limit</b></TD><TD>long</TD><TD>1L &lt;&lt; 60</TD>
             <TD>Set boundary for caching database pages in page pool. 
             By default Perst is using LRU algorithm for finding candidate for replacement.
             But for example for BLOBs this strategy is not optimal and fetching BLOB can
             cause flushing the whole page pool if LRU discipline is used. And with high
             probability fetched BLOB pages will no be used any more. So it is preferable not
             to cache BLOB pages at all (throw away such page immediately when it is not used any more).
             This parameter in conjunction with custom allocator allows to disable caching
             for BLOB objects. If you set value of "perst.page.lru.scope" property equal
             to base address of custom allocator (which will be used to allocate BLOBs), 
             then page containing objects allocated by this allocator will not be cached in page pool.
             </TD></TR>
             <TR><TD><code>perst.multiclient.support</code></TD><TD>bool</TD><TD>false</TD>
             <TD>Supports access to the same database file by multiple applications.
             In this case Perst will use file locking to synchronize access to the database file.
             An application MUST wrap any access to the database with BeginThreadThreansaction/EndThreadTransaction 
             methods. For read only access use TransactionMode.ReadOnly mode and if transaction may modify database then
             TransactionMode.ReadWrite mode should be used.
             </TD></TR>
             </TABLE>
             </remarks>
             <param name="name">name of the property</param>
             <param name="val">value of the property</param>
            
        </member>
        <member name="M:Perst.Storage.SetProperties(System.Collections.Hashtable)">
            
             <summary>Set database properties. This method should be invoked before opening database. 
             For list of supported properties please see <see cref="M:Perst.Storage.SetProperty(System.String,System.Object)">setProperty</see>. 
             All not recognized properties are ignored.
             </summary>
             <param name="props">collections with storage properties</param>
            
        </member>
        <member name="M:Perst.Storage.GetProperty(System.String)">
            
             <summary>Get property value.
             </summary>
             <param name="name">property name</param>
             <returns>value of the property previously assigned by setProperty or setProperties method
             or <b>null</b> if property was not set
             </returns>
            
        </member>
        <member name="M:Perst.Storage.GetProperties">
            
             <summary>
             Get all set properties
             </summary>
             <returns>all properties set by setProperty or setProperties method
             </returns>
            
        </member>
        <member name="M:Perst.Storage.Merge(System.Collections.IEnumerator[])">
            <summary>
            Merge results of several index searches. This method efficiently merge selections without loading objects themselve
            </summary>
            <param name="selections">Selections to be merged</param>
            <returns>Enumerator through merged result</returns>
        </member>
        <member name="M:Perst.Storage.Join(System.Collections.IEnumerator[])">
            <summary>
            Join results of several index searches. This method efficiently join selections without loading objects themselve
            </summary>
            <param name="selections">Selections to be joined</param>
            <returns>Enumerator through joined result</returns>
        </member>
        <member name="M:Perst.Storage.CreateClass(System.Type)">
            <summary>
            Create persistent class wrapper. This wrapper will implement virtual properties
            defined in specified class or interface, performing transparent loading and storing of persistent object
            </summary>
            <param name="type">Class or interface type of instantiated object</param>
            <returns>Wrapper for the specified class, implementing all virtual properties defined
            in it
            </returns>
        </member>
        <member name="M:Perst.Storage.BeginThreadTransaction(Perst.TransactionMode)">
            <summary>
            Begin per-thread transaction. Three types of per-thread transactions are supported: 
            exclusive, cooperative and serializable. In case of exclusive transaction, only one 
            thread can update the database. In cooperative mode, multiple transaction can work 
            concurrently and commit() method will be invoked only when transactions of all threads
            are terminated. Serializable transactions can also work concurrently. But unlike
            cooperative transaction, the threads are isolated from each other. Each thread
            has its own associated set of modified objects and committing the transaction will cause
            saving only of these objects to the database.To synchronize access to the objects
            in case of serializable transaction programmer should use lock methods
            of IResource interface. Shared lock should be set before read access to any object, 
            and exclusive lock - before write access. Locks will be automatically released when
            transaction is committed (so programmer should not explicitly invoke unlock method)
            In this case it is guaranteed that transactions are serializable.
            It is not possible to use <b>IPersistent.store()</b> method in
            serializable transactions. That is why it is also not possible to use Index and FieldIndex
            containers (since them are based on B-Tree and B-Tree directly access database pages
            and use <b>store()</b> method to assign OID to inserted object. 
            You should use <b>SortedCollection</b> based on T-Tree instead or alternative
            B-Tree implemenataion (set "perst.alternative.btree" property).
            </summary>
            <param name="mode"><b>TransactionMode.Exclusive</b>,  <b>TransactionMode.Cooperative</b>,
            <b>TransactionMode.ReplicationSlave</b> or <b>TransactionMode.Serializable</b>
            </param>
        </member>
        <member name="M:Perst.Storage.EndThreadTransaction">
            <summary>
            End per-thread transaction started by beginThreadTransaction method.
            <ul>
            <li>If transaction is <i>exclusive</i>, this method commits the transaction and
            allows other thread to proceed.</li><li>
            If transaction is <i>serializable</i>, this method commits sll changes done by this thread
            and release all locks set by this thread.</li><li>     
            If transaction is <i>cooperative</i>, this method decrement counter of cooperative
            transactions and if it becomes zero - commit the work</li></ul>
            </summary>
        </member>
        <member name="M:Perst.Storage.EndThreadTransaction(System.Int32)">
            <summary>
            End per-thread cooperative transaction with specified maximal delay of transaction
            commit. When cooperative transaction is ended, data is not immediately committed to the
            disk (because other cooperative transaction can be active at this moment of time).
            Instead of it cooperative transaction counter is decremented. Commit is performed
            only when this counter reaches zero value. But in case of heavy load there can be a lot of
            requests and so a lot of active cooperative transactions. So transaction counter never reaches zero value.
            If system crash happens a large amount of work will be lost in this case. 
            To prevent such scenario, it is possible to specify maximal delay of pending transaction commit.
            In this case when such timeout is expired, new cooperative transaction will be blocked until
            transaction is committed.
            </summary>
            <param name="maxDelay">maximal delay in milliseconds of committing transaction.  Please notice, that Perst could 
            not force other threads to commit their cooperative transactions when this timeout is expired. It will only
            block new cooperative transactions to make it possible to current transaction to complete their work.
            If <b>maxDelay</b> is 0, current thread will be blocked until all other cooperative trasnaction are also finished
            and changhes will be committed to the database.
            </param>
        </member>
        <member name="M:Perst.Storage.RollbackThreadTransaction">
            <summary>
            Rollback per-thread transaction. It is safe to use this method only for exclusive transactions.
            In case of cooperative transactions, this method rollback results of all transactions.
            </summary>
        </member>
        <member name="M:Perst.Storage.GetMemoryDump">
            <summary>
            Get database memory dump. This function returns hashmap which key is classes
            of stored objects and value - MemoryUsage object which specifies number of instances
            of particular class in the storage and total size of memory used by these instance.
            Size of internal database structures (object index, memory allocation bitmap) is associated with 
            <b>Storage</b> class. Size of class descriptors  - with <b>System.Type</b> class.
            <p>This method traverse the storage as garbage collection do - starting from the root object
            and recursively visiting all reachable objects. So it reports statistic only for visible objects.
            If total database size is significantly larger than total size of all instances reported
            by this method, it means that there is garbage in the database. You can explicitly invoke
            garbage collector in this case.</p> 
            </summary>
        </member>
        <member name="M:Perst.Storage.RegisterCustomAllocator(System.Type,Perst.CustomAllocator)">
            <summary>
            Register custom allocator for specified class. Instances of this and derived classes 
            will be allocated in the storage using specified allocator. 
            </summary>
            <param name="cls">class of the persistent object which instances will be allocated using this allocator</param>
            <param name="allocator">custom allocator</param>
        </member>
        <member name="M:Perst.Storage.CreateBitmapAllocator(System.Int32,System.Int64,System.Int64,System.Int64)">
            <summary>
            Create bitmap custom allocator
            </summary>
            <param name="quantum">size in bytes of allocation quantum. Should be power of two.</param>
            <param name="baseAddr">base address for allocator (it should match offset of multifile segment)</param>
            <param name="extension">size by which space mapped by allocator is extended each time when 
            no suitable hole is found in bitmap (it should be large enough to improve allocation speed and locality                                                                                                     
            of references)</param>
            <param name="limit">maximal size of memory allocated by this allocator (pass Long.MAX_VALUE if you do not 
            want to limit space)</param>
            <returns> created allocator</returns>
        </member>
        <member name="M:Perst.Storage.SetCustomSerializer(Perst.CustomSerializer)">
            <summary>
            Set custom serializer used fot packing/unpacking fields of persistent objects which types implemplemet 
            CustomSerializable interface
            </summary>
        </member>
        <member name="M:Perst.Storage.ClearObjectCache">
            <summary>
            Clear database object cache. This method can be used with "strong" object cache to avoid memory overflow.
            It is no valid to invoke this method when there are some uncommitted changes in the database
            (some modified objects). Also all variables containing references to persistent object should be reset after
            invocation of this method - it is not correct to accessed object directly though such variables, objects
            has to be reloaded from the storage
            </summary>
        </member>
        <member name="M:Perst.Storage.Store(System.Object)">
            <summary>
            Store object in storage
            </summary>
            <param name="obj">stored object</param>
        </member>
        <member name="M:Perst.Storage.Modify(System.Object)">
            <summary>
            Mark object as been modified
            </summary>
            <param name="obj">modified object</param>
        </member>
        <member name="M:Perst.Storage.Load(System.Object)">
            <summary>
            Load raw object
            </summary>
            <param name="obj">loaded object</param>
        </member>
        <member name="M:Perst.Storage.Deallocate(System.Object)">
            <summary>
            Deallocaste object
            </summary>
            <param name="obj">deallocated object</param>
        </member>
        <member name="M:Perst.Storage.GetOid(System.Object)">
            <summary>
            Get object identifier
            </summary>
            <param name="obj">inspected object</param>        
        </member>
        <member name="P:Perst.Storage.Root">
            <summary> Get/set storage root. Storage can have exactly one root object. 
            If you need to have several root object and access them by name (as is is possible 
            in many other OODBMSes), you should create index and use it as root object.
            Previous reference to the root object is rewritten but old root is not automatically deallocated.
            </summary>
        </member>
        <member name="P:Perst.Storage.Listener">
             <summary>
             Storage listener.
             </summary>
            
        </member>
        <member name="P:Perst.Storage.Loader">
            <summary>
            Set class loader. This class loader will be used to locate classes for 
            loaded class descriptors. If class loader is not specified or
            it did find the class, then class will be searched in all active assemblies
            </summary>
        </member>
        <member name="P:Perst.Storage.IsInsideThreadTransaction">
            <summary>
            Check if nested thread transaction is active
            </summary>       
        </member>
        <member name="P:Perst.Storage.UsedSize">
            <summary>
            Get total size of all allocated objects in the database
            </summary>
        </member>
        <member name="P:Perst.Storage.DatabaseSize">
            <summary>
            Get size of the database
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDefaultInitIndexSize">
            <summary> Initialial database index size - increasing it reduce number of inde reallocation but increase
            initial database size. Should be set before openning connection.
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDefaultObjectCacheInitSize">
            <summary> Initial capacity of object hash
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDatabaseFormatVersion">
            <summary>
            Current version of database format. 0 means that database is not initilized.
            Used to provide backward compatibility of Perst releases.
            </summary>
        </member>
        <member name="F:Perst.Impl.StorageImpl.dbDefaultExtensionQuantum">
            <summary> Database extension quantum. Memory is allocate by scanning bitmap. If there is no
            large enough hole, then database is extended by the value of dbDefaultExtensionQuantum 
            This parameter should not be smaller than dbFirstUserId
            </summary>
        </member>
        <member name="T:Perst.ReplicationSlaveStorage">
            <summary>
            Storage reciving modified pages from replication master and 
            been able to run read-only transactions 
            </summary>
        </member>
        <member name="M:Perst.ReplicationSlaveStorage.IsConnected">
            <summary>
            Check if socket is connected to the master host
            </summary>
            <returns><b>true</b> if connection between slave and master is sucessfully established</returns>
        </member>
        <member name="M:Perst.ReplicationSlaveStorage.WaitForModification">
            <summary>
            Wait until database is modified by master
            This method blocks current thread until master node commits trasanction and
            this transanction is completely delivered to this slave node
            </summary>
        </member>
        <member name="M:Perst.Impl.ReplicationSlaveStorageImpl.IsConnected">
            <summary>
            Check if socket is connected to the master host
            @return <code>true</code> if connection between slave and master is sucessfully established
            </summary>
        </member>
        <member name="M:Perst.Impl.ReplicationSlaveStorageImpl.WaitForModification">
            <summary>
            Wait until database is modified by master
            This method blocks current thread until master node commits trasanction and
            this transanction is completely delivered to this slave node
            </summary>
        </member>
        <member name="M:Perst.Impl.ReplicationSlaveStorageImpl.HandleError">
            <summary>
            When overriden by base class this method perfroms socket error handling
            @return <code>true</code> if host should be reconnected and attempt to send data to it should be 
            repeated, <code>false</code> if no more attmpts to communicate with this host should be performed 
            </summary>     
        </member>
        <member name="T:Perst.FullText.FullTextQuery">
            <summary> Base class for full test search query nodes.
            Query can be parsed by FullTextSearchHelper class or explicitly created by user.
            </summary>
        </member>
        <member name="M:Perst.FullText.FullTextQuery.Visit(Perst.FullText.FullTextQueryVisitor)">
            <summary> Query node visitor.
            It provides convenient way of iterating through query nodes.
            </summary>
        </member>
        <member name="M:Perst.FullText.FullTextQuery.#ctor(Perst.FullText.FullTextQuery.Operator)">
            <summary> Query node constructor</summary>
            <param name="op">operation code
            </param>
        </member>
        <member name="P:Perst.FullText.FullTextQuery.IsConstrained">
            <summary> This method checks that query can be executed by interection of keyword occurrences lists</summary>
            <returns> true if quuery can be executed by FullTextIndex, false otherwise
            </returns>
        </member>
        <member name="T:Perst.FullText.FullTextQueryBinaryOp">
            <summary> Binary node of full text query</summary>
        </member>
        <member name="M:Perst.FullText.FullTextQueryBinaryOp.Visit(Perst.FullText.FullTextQueryVisitor)">
            <summary> Query node visitor.</summary>
        </member>
        <member name="M:Perst.FullText.FullTextQueryBinaryOp.#ctor(Perst.FullText.FullTextQuery.Operator,Perst.FullText.FullTextQuery,Perst.FullText.FullTextQuery)">
            <summary> Binary node constructor</summary>
            <param name="op">operation code
            </param>
            <param name="left">left operand
            </param>
            <param name="right">right operand
            </param>
        </member>
        <member name="P:Perst.FullText.FullTextQueryBinaryOp.IsConstrained">
            <summary> This method checks that query can be executed by interection of keyword occurrences lists</summary>
            <returns> true if quuery can be executed by FullTextIndex, false otherwise
            </returns>
        </member>
        <member name="T:Perst.FullText.FullTextQueryMatchOp">
            <summary> Match node of full text query</summary>
        </member>
        <member name="F:Perst.FullText.FullTextQueryMatchOp.word">
            <summary> Matched word (shown be lowercvases and in normal form, unless used in quotes)</summary>
        </member>
        <member name="F:Perst.FullText.FullTextQueryMatchOp.pos">
            <summary> Position of word in the query (zero based)</summary>
        </member>
        <member name="F:Perst.FullText.FullTextQueryMatchOp.wno">
            <summary> Index of the word in query (set and used internally, should not be accessed by application)</summary>
        </member>
        <member name="M:Perst.FullText.FullTextQueryMatchOp.Visit(Perst.FullText.FullTextQueryVisitor)">
            <summary> Query node visitor.</summary>
        </member>
        <member name="M:Perst.FullText.FullTextQueryMatchOp.#ctor(Perst.FullText.FullTextQuery.Operator,System.String,System.Int32)">
            <summary> Match node constructor</summary>
            <param name="op">operation code (should ne MATCH or STICT_MATCH)
            </param>
            <param name="word">searched word
            </param>
            <param name="pos">position of word in the query
            </param>
        </member>
        <member name="P:Perst.FullText.FullTextQueryMatchOp.IsConstrained">
            <summary> Match node provides query constraint</summary>
        </member>
        <member name="T:Perst.FullText.FullTextQueryUnaryOp">
            <summary> Unary node of full text query</summary>
        </member>
        <member name="M:Perst.FullText.FullTextQueryUnaryOp.Visit(Perst.FullText.FullTextQueryVisitor)">
            <summary> Query node visitor.</summary>
        </member>
        <member name="M:Perst.FullText.FullTextQueryUnaryOp.#ctor(Perst.FullText.FullTextQuery.Operator,Perst.FullText.FullTextQuery)">
            <summary> Unary node constructor</summary>
            <param name="op">operation code
            </param>
            <param name="opd">operand
            </param>
        </member>
        <member name="P:Perst.FullText.FullTextQueryUnaryOp.IsConstrained">
            <summary> This method checks that query can be executed by interection of keyword occurrences lists</summary>
            <returns> true if quuery can be executed by FullTextIndex, false otherwise
            </returns>
        </member>
        <member name="T:Perst.ClassLoader">
            <summary>
            Interface to provide application apecific class loading
            </summary>
        </member>
        <member name="M:Perst.ClassLoader.LoadClass(System.String)">
            <summary>
            Load class with specified name.
            </summary>
            <param name="name">full name of the class to be loaded</param>
            <returns>loaded class or <b>null</b> if class can not be loaded</returns>
        </member>
        <member name="T:Perst.TransparentPersistenceAttribute">
            <summary>
            Attribute providing transparent persistency for context bound objects.
            It should be used for classes derived from PeristentContext class.
            Objects of these classes automatically on demand load their 
            content from the database and also automatically detect object modification.
            </summary>
        </member>
        <member name="T:Perst.Rectangle">
            <summary>
            Rectangle with integer coordinates. This class is used in spatial index.
            </summary>
        </member>
        <member name="M:Perst.Rectangle.Area">
            <summary>
            Rectangle area
            </summary>
        </member>
        <member name="M:Perst.Rectangle.JoinArea(Perst.Rectangle,Perst.Rectangle)">
            <summary>
            Area of covered rectangle for two sepcified rectangles
            </summary>
        </member>
        <member name="M:Perst.Rectangle.#ctor(Perst.Rectangle)">
            <summary>
            Create copy of the rectangle
            </summary>
        </member>
        <member name="M:Perst.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct rectangle with specified coordinates
            </summary>
        </member>
        <member name="M:Perst.Rectangle.Join(Perst.Rectangle)">
            <summary>
            Join two rectangles. This rectangle is updates to contain cover of this and specified rectangle.
            </summary>
            <param name="r">rectangle to be joined with this rectangle
            </param>
        </member>
        <member name="M:Perst.Rectangle.Join(Perst.Rectangle,Perst.Rectangle)">
            <summary>
             Non destructive join of two rectangles. 
            </summary>
            <param name="a">first joined rectangle
            </param>
            <param name="b">second joined rectangle
            </param>
            <returns>rectangle containing cover of these two rectangles
            </returns>
        </member>
        <member name="M:Perst.Rectangle.Intersects(Perst.Rectangle)">
            <summary>
            Checks if this rectangle intersects with specified rectangle
            </summary>
        </member>
        <member name="M:Perst.Rectangle.Contains(Perst.Rectangle)">
            <summary>
            Checks if this rectangle contains the specified rectangle
            </summary>
        </member>
        <member name="M:Perst.Rectangle.IsEmpty">
            <summary>
            Check if rectanlge is empty 
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Top">
            <summary>
            Smallest Y coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Left">
            <summary>
            Smallest X coordinate of the rectangle
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Bottom">
            <summary>
            Greatest Y coordinate  of the rectangle
            </summary>
        </member>
        <member name="P:Perst.Rectangle.Right">
            <summary>
            Greatest X coordinate  of the rectangle
            </summary>
        </member>
        <member name="T:Perst.VersionHistory">
            <summary> Collection of version of versioned object.
            Versioned object should be access through version history object.
            Instead of storing direct reference to Verson in some component of some other persistent object, 
            it is necessary to store reference to it's VersionHistory.
            </summary>
        </member>
        <member name="M:Perst.VersionHistory.CheckOut">
            <summary> Checkout current version: create successor of the current version.
            This version has to be checked-in in order to be placed in version history
            </summary>
            <returns> checked-out version
            
            </returns>
        </member>
        <member name="M:Perst.VersionHistory.GetLatestBefore(System.DateTime)">
            <summary> Get latest version before specified date
            </summary>
            <param name="timestamp">deadline
            </param>
            <returns> version with the largest timestamp less than specified <b>timestamp</b>
            
            </returns>
        </member>
        <member name="M:Perst.VersionHistory.GetEarliestAfter(System.DateTime)">
            <summary> Get earliest version adter specified date
            </summary>
            <param name="timestamp">deadline
            </param>
            <returns> version with the smallest timestamp greater than specified <b>timestamp</b>
            
            </returns>
        </member>
        <member name="M:Perst.VersionHistory.GetVersionByLabel(System.String)">
            <summary> Get version with specified label. If there are more than one version marked with 
            this label, then the latest one will be returned
            </summary>
            <param name="label">version label
            </param>
            <returns> latest version with specified label
            
            </returns>
        </member>
        <member name="M:Perst.VersionHistory.GetVersionById(System.String)">
            <summary> Get version with specified ID.
            </summary>
            <param name="id">version identifier
            </param>
            <returns> version with specified ID
            
            </returns>
        </member>
        <member name="M:Perst.VersionHistory.GetEnumerator">
            <summary> Get iterator through all version in version history
            Iteration is started from the root version and performed in direction of increaing
            version timestamp
            </summary>
            <returns>enumerator of all versions in version history
            </returns>
        </member>
        <member name="M:Perst.VersionHistory.#ctor(Perst.Version)">
            <summary> Create new version history
            </summary>
            <param name="root">root version
            
            </param>
        </member>
        <member name="P:Perst.VersionHistory.Current">
            <summary> Get/Set current version in version history.
            Current version can be explicitely set by setVersion or result of last checkOut
            is used as current version
            </summary>
        </member>
        <member name="P:Perst.VersionHistory.Root">
            <summary> Get root version
            </summary>
            <returns> root version in this version history
            
            </returns>
        </member>
        <member name="P:Perst.VersionHistory.AllVersions">
            <summary> Get all versions in version history
            </summary>
            <returns>array of versions sorted by date
            
            </returns>
        </member>
        <member name="P:Perst.VersionHistory.Latest">
            <summary> Get latest version in version history
            </summary>
            <returns> version with the largest timestamp 
            
            </returns>
        </member>
        <member name="T:Perst.BoundaryKind">
            <summary>
            Range boundary kind
            </summary>
        </member>
        <member name="T:Perst.SortedCollection">
            <summary>
            Interface of sorted collection.
            Sorted collections keeps in members in order specified by comparator.
            Members in the collections can be located using key or range of keys.
            The SortedCollection is efficient container of objects for in-memory databases.
            For databases which size is significatly larger than size of page pool, operation with SortedList
            can cause trashing and so very bad performance. Unlike other index structures SortedCollection
            doesn't store values of keys and so search in the collection requires fetching of its members.
            </summary>
        </member>
        <member name="M:Perst.SortedCollection.Get(System.Object)">
             <summary>
             Get member with specified key.
             </summary>
             <param name="key"> specified key. It should match with type of the index and should be inclusive.</param>
             <returns> object with this value of the key or <b>null</b> if key nmot found</returns>
             <exception cref="T:Perst.StorageError">StorageError(StorageError.KEY_NOT_UNIQUE) exception if there are more than 
             one objects in the collection with specified value of the key.  
             </exception>
            
        </member>
        <member name="M:Perst.SortedCollection.Get(System.Object,System.Object)">
             <summary>
             Get members which key value belongs to the specified range.
             Either from boundary, either till boundary either both of them can be <b>null</b>.
             In last case the method returns all objects from the collection.
             </summary>
             <param name="from"> inclusive low boundary</param>
             <param name="till"> inclusive high boundary</param>
             <returns> array of objects which keys belongs to the specified interval, ordered by key value</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Get(System.Object,Perst.BoundaryKind,System.Object,Perst.BoundaryKind)">
            <summary>
            Get members which key value belongs to the specified range.
            Either from boundary, either till boundary either both of them can be <b>null</b>.
            In last case the method returns all objects from the collection.
            </summary>
            <param name="from"> low boundary</param>
            <param name="fromKind"> kind of low boundary</param>
            <param name="till"> high boundary</param>
            <param name="tillKind"> kind of high boundary</param>
            <returns> array of objects which keys belongs to the specified interval, ordered by key value</returns>
        </member>
        <member name="M:Perst.SortedCollection.Add(System.Object)">
            <summary>
            Add new member to collection
            </summary>
            <param name="obj"> new member</param>
        </member>
        <member name="M:Perst.SortedCollection.Contains(System.Object)">
             <summary>
             Check if collections contains specified member
             </summary>
             <returns> <b>true</b> if specified member belongs to the collection</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Remove(System.Object)">
             <summary>
             Remove member from collection
             </summary>
             <param name="obj"> member to be removed</param>
             <returns><b>true</b> if member was successfully removed or <b>false</b> if member is not found</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Size">
             <summary>
             Get number of objects in the collection
             </summary>
             <returns> number of objects in the collection</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.ToArray">
             <summary>
             Get all objects in the index as array ordered by index key.
             </summary>
             <returns> array of objects in the index ordered by key value</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.ToArray(System.Type)">
            <summary> Get all objects in the index as array of specified type orderd by index key
            </summary>
            <param name="elemType">type of array element</param>
            <returns>array of objects in the index ordered by key value
            </returns>
        </member>
        <member name="M:Perst.SortedCollection.GetEnumerator(System.Object,System.Object)">
             <summary>
             Get iterator for traversing collection members  with key belonging to the specified range. 
             </summary>
             <param name="from"> inclusive low boundary</param>
             <param name="till"> inclusive high boundary</param>
             <returns> selection iterator</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.GetEnumerator(System.Object,Perst.BoundaryKind,System.Object,Perst.BoundaryKind)">
             <summary>
             Get iterator for traversing collection members  with key belonging to the specified range. 
             </summary>
             <param name="from"> low boundary</param>
             <param name="fromKind"> kind of low boundary</param>
             <param name="till"> high boundary</param>
             <param name="tillKind"> kind of till boundary</param>
             <returns> selection iterator</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Range(System.Object,System.Object)">
             <summary>
             Get enumerable set of collection members with key belonging to the specified range. 
             </summary>
             <param name="from"> inclusive low boundary</param>
             <param name="till"> inclusive high boundary</param>
             <returns>  enumerable set</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.Range(System.Object,Perst.BoundaryKind,System.Object,Perst.BoundaryKind)">
             <summary>
             Get enumerable set of collection members with key belonging to the specified range. 
             </summary>
             <param name="from"> low boundary</param>
             <param name="fromKind"> kind of low boundary</param>
             <param name="till"> high boundary</param>
             <param name="tillKind"> kind of till boundary</param>
             <returns> enumerable set</returns>
            
        </member>
        <member name="M:Perst.SortedCollection.GetComparator">
             <summary>
             Get comparator used in this collection
             </summary>
             <returns> collection comparator</returns>
            
        </member>
        <member name="P:Perst.SortedCollection.Item(System.Object)">
            <summary> Access element by key
            </summary>
        </member>
        <member name="P:Perst.SortedCollection.Item(System.Object,System.Object)">
            <summary> Access elements by key range
            </summary>
        </member>
        <member name="T:Perst.MultidimensionalIndex">
            <summary>
            Interface of multidimensional index.
            The main idea of this index is to provide efficient search of object using multiple search criteria, for example
            "select from StockOptions where Symbol between 'AAB' and 'ABC' and Price > 100 and Volume between 1000 and 10000".
            Each component of the object is represented as separate dimension in the index.
            </summary>
        </member>
        <member name="M:Perst.MultidimensionalIndex.Remove(System.Object)">
            <summary> Remove object from the index
            </summary>
            <param name="obj">object removed from the index. Object should contain indexed field. 
            </param>
            <returns><b>true</b> if member was successfully removed or <b>false</b> if member is not found</returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.Contains(System.Object)">
            <summary> 
            Check if index contains specified object
            </summary>
            <param name="obj">object to be searched in the index. Object should contain indexed field. 
            </param>
            <returns><b>true</b> if object is present in the index, <b>false</b> otherwise
            </returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.Add(System.Object)">
            <summary> Add object to the index. 
            </summary>
            <param name="obj">object to be inserted in index. 
            </param>
        </member>
        <member name="M:Perst.MultidimensionalIndex.GetEnumerator(System.Object)">
            <summary>
            Get iterator through objects matching specified pattern object.
            All fields which are part of multidimensional index and which values in pattern object is not null
            are used as filter for index members.
            </summary>
            <param name="pattern">object which is used as search pattern, non null values of components of 
            this object forms search condition</param>
            <returns>iterator through index members which field values are equal to correspondent non-null fields of pattern object</returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.GetEnumerator(System.Object,System.Object)">
            <summary>
            Get iterator through objects which field values belongs to the range specified by correspondent
            fields of low and high objects.
            </summary>
            <param name="low">pattern object specifying inclusive low boundary for field values. If there is no low boundary for some particular field
            it should be set to null. For scalar types (like int) you can use instead minimal possible value, 
            like int.MinValue. If low is null, then low boundary is not specified for all fields.</param>
            <param name="high">pattern object specifying inclusive high boundary for field values. 
            If there is no high boundary for some particular field it should be set to null. 
            For scalar types (like int) you can use instead maximal possible value, like int.MaxValue.
            If high is null, then high boundary is not specified for all fields.</param>
            <returns>iterator through index members which field values are belongs to the range specified by 
            correspondent fields of low and high objects</returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.Range(System.Object,System.Object)">
            <summary>
            Get enumerable for colelction of objects which field values belongs to the range specified by correspondent
            fields of low and high objects.
            </summary>
            <param name="low">pattern object specifying inclusive low boundary for field values. If there is no low boundary for some particular field
            it should be set to null. For scalar types (like int) you can use instead minimal possible value, 
            like int.MinValue. If low is null, then low boundary is not specified for all fields.</param>
            <param name="high">pattern object specifying inclusive high boundary for field values. 
            If there is no high boundary for some particular field it should be set to null. 
            For scalar types (like int) you can use instead maximal possible value, like int.MaxValue.
            If high is null, then high boundary is not specified for all fields.</param>
            <returns>iterator through index members which field values are belongs to the range specified by 
            correspondent fields of low and high objects</returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.QueryByExample(System.Object)">
            <summary>
            Get array of index members matching specified pattern object.
            All fields which are part of multidimensional index and which values in pattern object is not null
            are used as filter for index members.
            </summary>
            <param name="pattern">object which is used as search pattern, non null values of components of this object 
            forms search condition</param>
            <returns>array of index members which field values are equal to correspondent non-null fields of pattern object</returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.QueryByExample(System.Object,System.Object)">
            <summary>
            Get array of index members which field values belongs to the range specified by correspondent
            fields of low and high objects.
            </summary>
            <param name="low">pattern object specifying inclusive low boundary for field values. If there is no low boundary for some particular field
            it should be set to null. For scalar types (like int) you can use instead minimal possible value, 
            like int.MinValue. If low is null, then low boundary is not specified for all fields.</param>
            <param name="high">pattern object specifying inclusive high boundary for field values. 
            If there is no high boundary for some particular field it should be set to null. 
            For scalar types (like int) you can use instead maximal possible value, like int.MaxValue.
            If high is null, then high boundary is not specified for all fields.</param>
            <returns>array of index members which field values are belongs to the range specified by correspondent fields
            of low and high objects</returns>
        </member>
        <member name="M:Perst.MultidimensionalIndex.Optimize">
            <summary>
            Optimize index to make search more efficient.
            This operation cause complete reconstruction of the index and so may take a long time.
            Also please notice that this method doesn't build the ideally balanced tree - it just reinserts
            elements in the tree in random order
            </summary>
        </member>
        <member name="P:Perst.MultidimensionalIndex.Comparator">
             <summary>
             Get comparator used in this index
             </summary>
             <returns>comparator used to compare objects in this index</returns>
            
        </member>
        <member name="P:Perst.MultidimensionalIndex.Height">
            <summary>
            Height of the tree. Height of the tree can be used by application
            to determine when tree structure is no optimal and tree should be reconstructed 
            using optimize method.
            </summary>
        </member>
        <member name="T:Perst.JSQLNoSuchFieldException">
            <summary> Exception thown when field is not found during runtime lookup
            </summary>
        </member>
        <member name="M:Perst.JSQLNoSuchFieldException.#ctor(System.Type,System.String)">
            <summary> Constructor of exception
            </summary>
            <param name="target">class of the target object in which field was not found
            </param>
            <param name="fieldName">name of the locate field
            
            </param>
        </member>
        <member name="T:Perst.ISelfSerializable">
            <summary>
            Interface of the classes sleft responsible for their serialization
            </summary>
        </member>
        <member name="M:Perst.ISelfSerializable.Pack(Perst.ObjectWriter)">
            <summary>
            Serialize object
            </summary>
            <param name="writer">writer to be used for object serialization</param>
                   
        </member>
        <member name="M:Perst.ISelfSerializable.Unpack(Perst.ObjectReader)">
             <summary>
             Deserialize object
             </summary>
             <param name="reader">reader to be used for objet deserialization</param>
            
        </member>
        <member name="T:Perst.FullText.FullTextIndexableAttribute">
            <summary>
            Attribute for marking full text indexable fields used by Database class to create table descriptors. 
            </summary>
        </member>
        <member name="T:Perst.Blob">
            <summary>
            Interface to store/fetch large binary objects
            </summary>
        </member>
        <member name="M:Perst.Blob.GetStream">
            <summary>
            Get stream to fetch/store BLOB data 
            </summary>
            <returns>BLOB read/write stream</returns>
        </member>
        <member name="T:Perst.TimeSeriesTick">
            <summary>
            Interface for timeseries element.
            You should derive your time series element from this class
            and implement Time getter method.
            </summary>
        </member>
        <member name="P:Perst.TimeSeriesTick.Time">
            <summary>
            Get time series element timestamp (100 nanoseconds)
            </summary>
        </member>
        <member name="T:Perst.TimeSeriesBlock">
            <summary>
            Abstract base class for time series block.
            Progammer has to define its own block class derived from this class
            containign array of time series elements and providing accessors to the array elements 
            and Ticks getter method to access this whole array.
            </summary>
        </member>
        <member name="P:Perst.TimeSeriesBlock.Ticks">
            <summary>
            Get time series elements stored in this block.
            Returns preallocated array of time series element. Only <b>used</b>
            items of this array actually contains time series elements.
            </summary>
        </member>
        <member name="P:Perst.TimeSeriesBlock.Item(System.Int32)">
            <summary>
            Array elements accessor. 
            </summary>
        </member>
        <member name="T:Perst.TimeSeries">
            <summary>
            <p>
            Time series interface. Time series class is used for efficient
            handling of time series data. Ussually time series contains a very large number
            if relatively small elements which are ussually acessed in sucessive order. 
            To avoid overhead of loading from the disk each particular time series element, 
            this class group several subsequent time series elements together and store them 
            as single object (block).
            </p><p> 
            As far as C# currently has no templates and
            Perst need to know format of block class, it is responsibity of prgorammer
            to create block implementation derived from TimeSeriesBlock class
            and containing array of time series elements. Size of this array specifies
            the size of the block.
            </p>
            </summary>
        </member>
        <member name="M:Perst.TimeSeries.Add(Perst.TimeSeriesTick)">
            <summary>
            Add new tick to time series
            </summary>
            <param name="tick">new time series element</param>
        </member>
        <member name="M:Perst.TimeSeries.GetEnumerator(System.DateTime,System.DateTime)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>forward iterator within specified range</returns>
        </member>
        <member name="M:Perst.TimeSeries.GetEnumerator(Perst.IterationOrder)">
            <summary>
            Get iterator through all time series elements
            </summary>
            <param name="order">direction of iteration</param>
            <returns>iterator in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.GetEnumerator(System.DateTime,System.DateTime,Perst.IterationOrder)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <param name="order">direction of iteration</param>
            <returns>iterator within specified range in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.Range(System.DateTime,System.DateTime)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>forward iterator within specified range</returns>
        </member>
        <member name="M:Perst.TimeSeries.Range(Perst.IterationOrder)">
            <summary>
            Get iterator through all time series elements
            </summary>
            <param name="order">direction of iteration</param>
            <returns>iterator in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.Range(System.DateTime,System.DateTime,Perst.IterationOrder)">
            <summary>
            Get forward iterator for time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <param name="order">direction of iteration</param>
            <returns>iterator within specified range in specified direction</returns>
        </member>
        <member name="M:Perst.TimeSeries.From(System.DateTime)">
            <summary>
            Get forward iterator for time series elements with timestamp greater or equal than specified
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <returns>forward iterator</returns>
        </member>
        <member name="M:Perst.TimeSeries.Till(System.DateTime)">
            <summary>
            Get backward iterator for time series elements with timestamp less or equal than specified
            </summary>
            <param name="till">inclusive time of the eding of interval</param>
            <returns>backward iterator</returns>
        </member>
        <member name="M:Perst.TimeSeries.Reverse">
            <summary>
            Get backward iterator for time series elements 
            </summary>
            <returns>backward iterator</returns>
        </member>
        <member name="M:Perst.TimeSeries.Contains(System.DateTime)">
            <summary>
            Check if data is available in time series for the specified time
            </summary>
            <param name="timestamp">time series element timestamp</param>
            <returns><b>true</b> if there is element in time series with such timestamp, 
            <b>false</b> otherwise</returns>
        </member>
        <member name="M:Perst.TimeSeries.Remove(System.DateTime,System.DateTime)">
            <summary>
            Remove time series elements belonging to the specified range
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.RemoveFrom(System.DateTime)">
            <summary>
            Remove time series elements with timestamp greater or equal then specified
            </summary>
            <param name="from">inclusive time of the begging of interval</param>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.RemoveTill(System.DateTime)">
            <summary>
            Remove time series elements with timestamp less or equal then specified
            </summary>
            <param name="till">inclusive time of the ending of interval</param>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.RemoveAll">
            <summary>
            Remove all time series elements
            </summary>
            <returns>number of removed elements</returns>
        </member>
        <member name="M:Perst.TimeSeries.CountTicks">
            <summary>
            Get number of elements in time series
            </summary>
            <returns>number of elements in time series</returns>
        </member>
        <member name="P:Perst.TimeSeries.FirstTime">
            <summary>
            Get timestamp of first time series element
            </summary>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorClass.KEY_NOT_FOUND) if time series is empy</exception>
        </member>
        <member name="P:Perst.TimeSeries.LastTime">
            <summary>
            Get timestamp of last time series element
            </summary>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorClass.KEY_NOT_FOUND) if time series is empy</exception>
        </member>
        <member name="P:Perst.TimeSeries.Item(System.DateTime)">
            <summary> 
            Get tick for specified data
            </summary>
            <param name="timestamp">time series element timestamp</param>
            <exception cref="T:Perst.StorageError">StorageError(StorageError.ErrorClass.KEY_NOT_FOUND) if no element with such timestamp exists</exception>
        </member>
        <member name="T:Perst.PersistentComparator">
            <summary> Base class for persistent comparator used in SortedCollection class
            </summary>
        </member>
        <member name="M:Perst.PersistentComparator.CompareMembers(System.Object,System.Object)">
            <summary> 
            Compare two members of collection
            </summary>
            <param name="m1"> first members</param>
            <param name="m2"> second members</param>
            <returns>negative number if m1 &lt; m2, zero if m1 == m2 and positive number if m1 &gt; m2</returns>
        </member>
        <member name="M:Perst.PersistentComparator.CompareMemberWithKey(System.Object,System.Object)">
            <summary>
            Compare member with specified search key
            </summary>
            <param name="mbr"> collection member</param>
            <param name="key"> search key</param>
            <returns>negative number if mbr &lt; key, zero if mbr == key and positive number if mbr &gt; key</returns>
        </member>
        <member name="T:Perst.CompileError">
            <summary> Exception thrown by compiler
            </summary>
        </member>
        <member name="T:Perst.Relation">
            <summary> Class representing relation between owner and members
            </summary>
        </member>
        <member name="M:Perst.Relation.#ctor(System.Object)">
            <summary> Relation constructor. Creates empty relation with specified owner and no members. 
            Members can be added to the relation later.
            </summary>
            <param name="owner">owner of the relation
            
            </param>		
        </member>
        <member name="P:Perst.Relation.Owner">
            <summary>Get/Set relation owner
            </summary>
        </member>
        <member name="T:Perst.CustomSerializable">
            <summary>
            Interface used to mark objects serialized using custom serializer
            </summary>
        </member>
        <member name="M:Perst.CustomSerializable.ToString">
            
             <summary>
             Get string representation of object. This string representation may be used
             by CustomSerailize.parse method to create new instance of this object
             </summary>
             <returns>string representation of object</returns>
            
        </member>
        <member name="T:Perst.Projection">
            <summary>
            Class use to project selected objects using relation field. 
            For all selected objects (specified by array ort iterator), 
            value of specified field (of IPersistent, array of IPersistent, Link or Relation type)
            is inspected and all referenced object for projection (duplicate values are eliminated)
            </summary>
        </member>
        <member name="M:Perst.Projection.#ctor(System.Type,System.String)">
            <summary>
            Constructor of projection specified by class and field name of projected objects
            </summary>
            <param name="type">base class for selected objects</param>
            <param name="fieldName">field name used to perform projection</param>
        </member>
        <member name="M:Perst.Projection.#ctor">
            <summary>
            Default constructor of projection. This constructor should be used
            only when you are going to derive your class from Projection and redefine
            map method in it or sepcify type and fieldName later using setProjectionField
            method
            </summary>
        </member>
        <member name="M:Perst.Projection.SetProjectionField(System.Type,System.String)">
            <summary>
            Specify class of the projected objects and projection field name
            </summary>
            <param name="type">base class for selected objects</param>
            <param name="fieldName">field name used to perform projection</param>
        </member>
        <member name="M:Perst.Projection.Project(System.Object[])">
            <summary>
            Project specified selection
            </summary>
            <param name="selection">array with selected object</param>
        </member>
        <member name="M:Perst.Projection.Project(System.Object)">
            <summary>
            Project specified object
            </summary>
            <param name="obj">selected object</param>
        </member>
        <member name="M:Perst.Projection.Project(System.Collections.IEnumerator)">
            <summary>
            Project specified selection
            </summary>
            <param name="selection">enumerator specifying selceted objects</param>
        </member>
        <member name="M:Perst.Projection.Project(System.Collections.IEnumerable)">
            <summary>
            Project specified selection
            </summary>
            <param name="selection">enumerator specifying selceted objects</param>
        </member>
        <member name="M:Perst.Projection.Join(Perst.Projection)">
            <summary>
            Join this projection with another projection.
            Result of this join is set of objects present in both projections.
            </summary>
            <param name="prj">joined projection</param>
        </member>
        <member name="M:Perst.Projection.ToArray">
            <summary>
            Get result of preceding project and join operations
            </summary>
            <returns>array of objects</returns>
        </member>
        <member name="M:Perst.Projection.ToArray(System.Type)">
            <summary>
            Get result of preceding project and join operations
            </summary>
            <param name="elemType">type of result array element</param>
            <returns>array of objects</returns>
        </member>
        <member name="M:Perst.Projection.GetEnumerator">
            <summary>
            Get enumerator for result of preceding project and join operations
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Perst.Projection.Reset">
            <summary>
            Reset projection - clear result of prceding project and join operations
            </summary>
        </member>
        <member name="M:Perst.Projection.Add(System.Object)">
            <summary>
            Add object to the set
            </summary>
            <param name="obj">object to be added to the set</param>
        </member>
        <member name="M:Perst.Projection.Map(System.Object)">
            <summary>
            Get related objects for the object obj. 
            It is possible to redifine this method in derived classes 
            to provide application specific mapping
            </summary>
            <param name="obj">object from the selection</param>
        </member>
        <member name="P:Perst.Projection.Length">
            <summary>
            Get number of objets in the result 
            </summary>
        </member>
        <member name="T:Perst.Key">
            <summary> Class for specifying key value (neededd to access obejct by key usig index)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Boolean)">
            <summary> Constructor of boolean key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.SByte)">
            <summary> Constructor of signed byte key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte)">
            <summary> Constructor of byte key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char)">
            <summary> Constructor of char key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int16)">
            <summary> Constructor of short key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt16)">
            <summary> Constructor of unsigned short key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int32)">
            <summary> Constructor of int key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt32)">
            <summary> Constructor of unsigned int key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Enum)">
            <summary> Constructor of enum key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int64)">
            <summary> Constructor of long key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt64)">
            <summary> Constructor of unsigned long key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Single)">
            <summary> Constructor of float key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Double)">
            <summary> Constructor of double key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Decimal)">
            <summary> Constructor of decimal key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Guid)">
            <summary> Constructor of Guid key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.DateTime)">
            <summary> Constructor of date key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.String)">
            <summary> Constructor of string key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.ValueType)">
            <summary> Constructor of key of user defined type (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char[])">
            <summary> Constructor of array of char key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte[])">
            <summary> Constructor of array of byte key (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object[])">
            <summary>
            Constructor of compound key (boundary is inclusive)
            </summary>
            <param name="v">array of compound key values</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Object)">
            <summary>
            Constructor of compound key with two values (boundary is inclusive)
            </summary>
            <param name="v1">first value of compund key</param>
            <param name="v2">second value of compund key</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Int32)">
            <summary> Constructor of key with persistent object reference (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object)">
            <summary> Constructor of key with persistent object reference (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(Perst.IPersistent)">
            <summary> Constructor of key with persistent object reference (boundary is inclusive)
            </summary>
        </member>
        <member name="M:Perst.Key.#ctor(System.Boolean,System.Boolean)">
            <summary> Constructor of boolean key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.SByte,System.Boolean)">
            <summary> Constructor of signed byte key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte,System.Boolean)">
            <summary> Constructor of byte key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char,System.Boolean)">
            <summary> Constructor of char key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int16,System.Boolean)">
            <summary> Constructor of short key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt16,System.Boolean)">
            <summary> Constructor of unsigned short key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Enum,System.Boolean)">
            <summary> Constructor of int key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int32,System.Boolean)">
            <summary> Constructor of int key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt32,System.Boolean)">
            <summary> Constructor of unsigned int key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Int64,System.Boolean)">
            <summary> Constructor of long key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.UInt64,System.Boolean)">
            <summary> Constructor of unsigned long key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Single,System.Boolean)">
            <summary> Constructor of float key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Double,System.Boolean)">
            <summary> Constructor of double key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Decimal,System.Boolean)">
            <summary> Constructor of decimal key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Guid,System.Boolean)">
            <summary> Constructor of Guid key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.DateTime,System.Boolean)">
            <summary> Constructor of date key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.String,System.Boolean)">
            <summary> Constructor of string key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Char[],System.Boolean)">
            <summary> Constructor of array of char key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Byte[],System.Boolean)">
            <summary> Constructor of array of byte key
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object[],System.Boolean)">
            <summary>
            Constructor of compound key (boundary is inclusive)
            </summary>
            <param name="v">array of compound key values</param>
            <param name="inclusive">whether boundary is inclusive or exclusive</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Object,System.Boolean)">
            <summary>
            Constructor of compound key with two values (boundary is inclusive)
            </summary>
            <param name="v1">first value of compund key</param>
            <param name="v2">second value of compund key</param>
            <param name="inclusive">whether boundary is inclusive or exclusive</param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Int32,System.Boolean)">
            <summary> Constructor of key with persistent object reference
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(Perst.IPersistent,System.Boolean)">
            <summary> Constructor of key with persistent object reference
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.ValueType,System.Boolean)">
            <summary> Constructor of key of user defined type
            </summary>
            <param name="v">key value
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            
            </param>
        </member>
        <member name="M:Perst.Key.#ctor(System.Object,System.Type,System.Boolean)">
            <summary> Constructor of key with given value and specified target type
            </summary>
            <param name="v">key value
            </param>
            <param name="t">target key type
            </param>
            <param name="inclusive">whether boundary is inclusive or exclusive
            </param>
        </member>
        <member name="T:Perst.ReplicationMasterStorage">
            <summary>
            Storage performing replication of changed pages to specified slave nodes.
            </summary>
        </member>
        <member name="M:Perst.ReplicationMasterStorage.GetNumberOfAvailableHosts">
            <summary>
            Get number of currently available slave nodes
            </summary>
            <returns>number of online replication slaves</returns>        
        </member>
        <member name="T:Perst.FullText.FullTextSearchHelper">
            <summary> Helper class for full text search.
            This class provides functionality for parsing and stemming query
            and tuning document rank calculation
            </summary>
        </member>
        <member name="M:Perst.FullText.FullTextSearchHelper.GetNormalForms(System.String,System.String)">
            <summary> Perform stemming of the word</summary>
            <param name="word">word to be stemmed
            </param>
            <param name="language">language of the word (null if unknown)
            </param>
            <returns> normal forms of the word (some words belongs to more than one part of the speech, so there
            are can be more than one normal form)
            </returns>
        </member>
        <member name="M:Perst.FullText.FullTextSearchHelper.ParseText(System.IO.TextReader)">
            <summary> Split text of the documents into tokens</summary>
            <param name="reader">stream with document text
            </param>
            <returns> array of occurrences of words in thedocument
            </returns>
        </member>
        <member name="M:Perst.FullText.FullTextSearchHelper.IsStopWord(System.String)">
            <summary> Check if word is stop word and should bw not included in index</summary>
            <param name="word">lowercased word
            </param>
            <returns> true if word is in stop list, false otherwize
            </returns>
        </member>
        <member name="P:Perst.FullText.FullTextSearchHelper.OccurrenceKindWeights">
            <summary> Get occurrence kind weight. Occurrence kinds can be: in-title, in-header, emphased,...
            It is up to the document scanner implementation how to enumerate occurence kinds.
            These is only one limitation - number of difference kinds should not exceed 8.
            </summary>
            <returns> array with weights of each occurrence kind
            </returns>
        </member>
        <member name="P:Perst.FullText.FullTextSearchHelper.NearnessWeight">
            <summary> Get weight of nearness criteria in document rank.
            Document rank is calculated as (keywordRank*(1 + nearness*nearnessWeight))
            </summary>
            <returns> weight of nearness criteria
            </returns>
        </member>
        <member name="P:Perst.FullText.FullTextSearchHelper.WordSwapPenalty">
            <summary> Get penalty of inverse word order in the text.
            Assume that document text contains phrase "ah oh ugh".
            And query "ugh ah" is executed. The distance between "ugh" and "ah"
            in the document text is 6. But as far as them are in difference order than in query, 
            this distance will be multiplied on "swap penalty", so if swap penalty is 10, then distance
            between these two word is considered to be 60.
            </summary>
            <returns> swap penalty
            </returns>
        </member>
        <member name="T:Perst.CustomSerializer">
            <summary>
            Interface of custome serializer
            </summary>
        </member>
        <member name="M:Perst.CustomSerializer.Pack(System.Object,Perst.ObjectWriter)">
             <summary>
             Serialize object
             </summary>
             <param name="obj">object to be packed</param>
             <param name="writer">writer to be used for object serialization</param>
            
        </member>
        <member name="M:Perst.CustomSerializer.Unpack(Perst.ObjectReader)">
             <summary>
             Create and deserialize object
             </summary>
             <param name="reader">reader to be used for object deserialization</param>
             <returns>created and unpacked object</returns>
            
        </member>
        <member name="M:Perst.CustomSerializer.Unpack(System.Object,Perst.ObjectReader)">
             <summary>
             Deserialize object
             </summary>
             <param name="obj">unpacked object</param>
             <param name="reader">reader to be used for object deserialization</param>
            
        </member>
        <member name="M:Perst.CustomSerializer.Create(System.Type)">
            <summary>
            Create instance of specified type
            </summary>    
            <param name="type">type of the created object</param>        
            <returns>created object</returns>
        </member>
        <member name="M:Perst.CustomSerializer.Parse(System.String)">
             <summary>
             Create object from its string representation
             </summary>
             <param name="str">string representation of object (created by ToString() method)</param>
            
        </member>
        <member name="M:Perst.CustomSerializer.Print(System.Object)">
             <summary>
             Get string representation of the object
             </summary>
             <param name="obj">object which string representation is taken</param>
            
        </member>
        <member name="M:Perst.CustomSerializer.IsApplicable(System.Type)">
             <summary>
             Check if serializer can pack objects of this type
             </summary>
             <param name="type">inspected object type</param>
             <returns>true if serializer can pack instances of this type</returns>
            
        </member>
        <member name="M:Perst.CustomSerializer.IsEmbedded(System.Object)">
             <summary>
             Check if serializer can pack this object component
             </summary>
             <param name="obj">object component to be packed</param>
             <returns>true if serializer can pack this object inside some other object</returns>
            
        </member>
        <member name="T:Perst.JSQLNullPointerException">
            <summary> Exception thown when null reference field is dereferenced
            </summary>
        </member>
        <member name="M:Perst.JSQLNullPointerException.#ctor(System.Type,System.String)">
            <summary> Constructor of exception
            </summary>
            <param name="target">class of the target object in which field was not found
            </param>
            <param name="fieldName">name of the locate field
            
            </param>
        </member>
        <member name="T:Perst.Impl.CILGenerator">
            <summary>
            Generate code for condition
            </summary>
        </member>
        <member name="T:Perst.CustomAllocator">
            <summary>
            Custom allocator interface. Custom allocator can be used for more efficiently 
            allocate space using application specific semantic of the object. For example,
            application can place all BLOBs (images, texts, video,...) in separate file, located at separate disk
            and keep file with the rest of the data (metadata describing this BLOBs) relatively small, improving
            speed of search operations. Such separation of BLOBs and their descriptors can be achieved
            using custom allocator in conjunction with multifile. First segment is used for allocation of normal
            (non-BLOB) objects. It's size can be set practically unlimited: 0x1000 0000 0000 0000.
            And second segment should be used by custom allocator to allocate BLOBs. So BLOBs offsets are started
            from 0x1000000000000000 and BLOB content will be stored in separate file which in turn can be located 
            at separate disk.
            </summary>summary>
        </member>
        <member name="M:Perst.CustomAllocator.Allocate(System.Int64)">
            <summary>
            Allocate object
            </summary>
            <param name="size">allocated object size</param>
            <returns>position of the object in daatbase file.
            It should not overlap with space covered by main database allocation bitmap</returns>
        </member>
        <member name="M:Perst.CustomAllocator.Reallocate(System.Int64,System.Int64,System.Int64)">
            <summary>
            Reallocate object previously allocated by this allocator.
            This method should try to extend or shrink this object in its current location
            and if it is not possible, allocate new space for the object and free its old location.
            </summary>
            <param name="pos">old position of the object</param>
            <param name="oldSize">old size of the object</param>
            <param name="newSize">new size of the object</param>
            <returns>new position of the object (it can be equal to old position)</returns>
        </member>
        <member name="M:Perst.CustomAllocator.Free(System.Int64,System.Int64)">
             <summary>
             Deallocate object previously allocated by this allocator.
             Space used by this object can not be reused until transaction commit (when commit method is called for this
             allocator)
             </summary>
             <param name="pos">position of the object</param>
            <param name="size">size of allocated object</param>
        </member>
        <member name="M:Perst.CustomAllocator.Commit">
            <summary>
            Make it possible to reused space of all previously deallocated shadow objects. 
            </summary>
        </member>
        <member name="T:Perst.CodeGeneratorException">
            <summary>
            Exception thrown by code generator
            </summary>
        </member>
        <member name="T:Perst.StorageFactory">
            <summary> Storage factory
            </summary>
        </member>
        <member name="M:Perst.StorageFactory.CreateStorage">
            <summary> Create new instance of the storage
            </summary>
            <returns>instance of the storage (unopened,you should explicitely invoke open method)
            </returns>
        </member>
        <member name="M:Perst.StorageFactory.CreateReplicationMasterStorage(System.Int32,System.String[],System.Int32)">
             <summary>
             Create new instance of the master node of replicated storage. There are two kinds of replication slave nodes:
             statically defined and dynamically added. First one are specified by replicationSlaveNodes parameter.
             When replication master is started it tries to eastablish connection with all of the specified nodes. 
             It is expected that state of each such node is synchronized with state of the master node.
             It is not possible to add or remove static replication slave node without stopping master node.
             Dynamic slave nodes can be added at any moment of time. Replication master will send to such node complete 
             snapshot of the database.
             </summary>
             <param name="port">socket port at which replication master will listen for dynamic slave nodes connections. 
             If this parameter is -1, then no dynamic slave node conenctions are accepted.</param> 
             <param name="replicationSlaveNodes">addresses of hosts to which replication will be performed. 
             Address as specified as NAME:PORT</param>
             <param name="asyncBufSize">if value of this parameter is greater than zero then replication will be 
             asynchronous, done by separate thread and not blocking main application. 
             Otherwise data is send to the slave nodes by the same thread which updates the database.
             If space asynchronous buffer is exhausted, then main thread willbe also blocked until the
             data is send.</param>
             <returns>new instance of the master storage (unopened, you should explicitely invoke open method)</returns>
            
        </member>
        <member name="M:Perst.StorageFactory.CreateReplicationSlaveStorage(System.Int32)">
            <summary>
            Create new instance of the static slave node of replicated storage.
            The address of this host should be sepecified in the replicationSlaveNodes
            parameter of createReplicationMasterStorage method. When replication master
            is started it tries to eastablish connection with all of the specified nodes. 
            </summary>
            <param name="slavePort">socket port at which connection from master will be established</param>
            <returns>new instance of the slave storage (unopened, you should explicitely invoke open method)</returns>
        </member>
        <member name="M:Perst.StorageFactory.AddReplicationSlaveStorage(System.String,System.Int32)">
             <summary>
             Add new instance of the dynamic slave node of replicated storage. 
             </summary>
             <param name="replicationMasterNode">name of the host where replication master is running</param>
             <param name="masterPort">replication master socket port to which connection should be established</param>
             <returns>new instance of the slave storage (unopened, you should explicitely invoke open method)</returns>
            
        </member>
        <member name="P:Perst.StorageFactory.Instance">
            <summary> Get instance of storage factory.
            So new storages should be create in application in the following way:
            <see cref="M:Perst.StorageFactory.Instance.CreateStorage"/>
            </summary>
        </member>
        <member name="F:Perst.TransactionMode.Exclusive">
            <summary>
            Exclusive per-thread transaction: each thread access database in exclusive mode
            </summary>
        </member>
        <member name="F:Perst.TransactionMode.Cooperative">
            <summary>
            Cooperative mode; all threads share the same transaction. Commit will commit changes made
            by all threads. To make this schema work correctly, it is necessary to ensure (using locking)
            that no thread is performing update of the database while another one tries to perform commit.
            Also please notice that rollback will undo the work of all threads. 
            </summary>
        </member>
        <member name="F:Perst.TransactionMode.Serializable">
            <summary>
            Serializable per-thread transaction. Unlike exclusive mode, threads can concurrently access database, 
            but effect will be the same as them work exclusively.
            To provide such behavior, programmer should lock all access objects (or use hierarchical locking).
            When object is updated, exclusive lock should be set, otherwise shared lock is enough.
            Lock should be preserved until the end of transaction.
            </summary>
        </member>
        <member name="F:Perst.TransactionMode.ReplicationSlave">
            <summary>
            Read only transaction which can be started at replication slave node.
            It runs concurrently with receiving updates from master node.
            </summary>
        </member>
        <member name="T:Perst.MarshalByRefPersistent">
            <summary> Base class for persistent capable objects with marshal be reference semantic
            </summary>
        </member>
        <member name="T:Perst.L2ListElem">
            <summary>
            Double linked list element.
            </summary>
        </member>
        <member name="M:Perst.L2ListElem.Prune">
            <summary>
            Make list empty. 
            This method should be applied to list header. 
            </summary>
        </member>
        <member name="P:Perst.L2ListElem.Next">
            <summary>
            Get next list element. 
            Been call for the last list element, this method will return first element of the list 
            or list header
            </summary>
        </member>
        <member name="P:Perst.L2ListElem.Prev">
            <summary>
            Get previous list element. 
            Been call for the first list element, this method will return last element of the list 
            or list header
            </summary>
        </member>
        <member name="T:Perst.L2List">
            <summary>
            Double linked list.
            </summary>
        </member>
        <member name="M:Perst.L2List.Clear">
            <summary>
            Make list empty. 
            </summary>
        </member>
        <member name="M:Perst.L2List.Prepend(Perst.L2ListElem)">
            <summary>
            Insert element at the beginning of the list
            </summary>
        </member>
        <member name="M:Perst.L2List.Append(Perst.L2ListElem)">
            <summary>
            Insert element at the end of the list
            </summary>
        </member>
        <member name="M:Perst.L2List.Remove(Perst.L2ListElem)">
            <summary>
            Remove element from the list
            </summary>
        </member>
        <member name="M:Perst.L2List.Add(Perst.L2ListElem)">
            <summary>
            Add element to the list
            </summary>
        </member>
        <member name="P:Perst.L2List.Head">
            <summary>
            Get list head element
            </summary>
            <returns>list head element or null if list is empty
            </returns>>
        </member>
        <member name="P:Perst.L2List.Tail">
            <summary>
            Get list tail element
            </summary>
            <returns>list tail element or null if list is empty
            </returns>
        </member>
        <member name="T:Perst.FullText.Occurrence">
            <summary> Occurrence of word in the document</summary>
        </member>
        <member name="F:Perst.FullText.Occurrence.word">
            <summary> Word (lowercased)</summary>
        </member>
        <member name="F:Perst.FullText.Occurrence.position">
            <summary> Position of word in document text (0 based)</summary>
        </member>
        <member name="F:Perst.FullText.Occurrence.kind">
            <summary> Word occurrence kind. 
            It is up to the document scanner implementation how to enumerate occurence kinds.
            These is only one limitation - number of difference kinds should not exceed 8.
            </summary>
        </member>
        <member name="M:Perst.FullText.Occurrence.#ctor(System.String,System.Int32,System.Int32)">
            <summary> Occurrence constructor</summary>
            <param name="word">lowercased word 
            </param>
            <param name="position">offset of word from the beginning of document text
            </param>
            <param name="kind">word occurrence kind (should be less than 8)
            </param>
        </member>
        <member name="T:Perst.Database">
            <summary>
            This class emulates relational database on top of Perst storage
            It maintain class extends, associated indices, prepare queries.
            Starting from 2.72 version of Perst.Net, it supports automatic
            creation of table descriptors when Database class is used.
            So now it is not necessary to explicitly create tables and indices -
            the Database class will create them itself on demand.
            Indexable attribute should be used to mark key fields for which index should be created.
            Table descriptor is created when
            instance of the correspondent class is first time stored in the
            database. Perst creates table descriptors for all derived classes up
            to the root Perst.Persistent class.
            </summary>
        </member>
        <member name="M:Perst.Database.#ctor(Perst.Storage,System.Boolean)">
            <summary> 
            Constructor of database. This method initialize database if it not initialized yet.
            </summary>
            <param name="storage">opened storage. Storage should be either empty (non-initialized, either
            previously initialized by the this method. It is not possible to open storage with 
            root object other than table index created by this constructor.
            </param>
            <param name="multithreaded"><b>true</b> if database should support concurrent access
            to the data from multiple threads</param>
        </member>
        <member name="M:Perst.Database.#ctor(Perst.Storage,System.Boolean,System.Boolean,Perst.FullText.FullTextSearchHelper)">
            <summary> 
            Constructor of database. This method initialize database if it not initialized yet.
            </summary>
            <param name="storage">opened storage. Storage should be either empty (non-initialized, either
            previously initialized by the this method. It is not possible to open storage with 
            root object other than table index created by this constructor.
            </param>
            <param name="multithreaded"><b>true</b> if database should support concurrent access</param>
            <param name="autoRegisterTables">automatically create tables descriptors for instances 
            of new classes inserted in the database</param>
            <param name="helper">helper for full text index</param>
        </member>
        <member name="M:Perst.Database.#ctor(Perst.Storage)">
            <summary> 
            Constructor of single threaded database. This method initialize database if it not initialized yet.
            </summary>
            <param name="storage">opened storage. Storage should be either empty (non-initialized, either
            previously initialized by the this method. It is not possible to open storage with 
            root object other than table index created by this constructor.
            </param>
        </member>
        <member name="M:Perst.Database.BeginTransaction">
            <summary>
            Begin transaction
            </summary>
        </member>
        <member name="M:Perst.Database.CommitTransaction">
            <summary>
            Commit transaction
            </summary>
        </member>
        <member name="M:Perst.Database.RollbackTransaction">
            <summary>
            Rollback transaction
            </summary>
        </member>
        <member name="M:Perst.Database.CreateTable(System.Type)">
            <summary>
            Create table for the specified class.
            This function does nothing if table for such class already exists.
            Since version 2.72 of Perst.Net it is not necessary to create table and index 
            descriptors explicitly: them are automatically create when object is inserted in the 
            database first time (to mark fields for which indices should be created, 
            use Indexable attribute)
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <returns> <b>true</b> if table is created, <b>false</b> if table 
            alreay exists
            </returns>
        </member>
        <member name="M:Perst.Database.DropTable(System.Type)">
            <summary>
            Drop table associated with this class. Do nothing if there is no such table in the database.
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <returns> <b>true</b> if table is deleted, <b>false</b> if table 
            is not found
            </returns>
        </member>
        <member name="M:Perst.Database.AddRecord(System.Object)">
            <summary>
            Add new record to the table. Record is inserted in table corresponding to the class of the object.
            Record will be automatically added to all indices existed for this table.
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...
            </summary>
            <param name="record">object to be inserted in the table</param>
            <returns> <b>true</b> if record was successfully added to the table, <b>false</b>
            if there is already such record (object with the same ID) in the table
            </returns>
            <exception cref="T:Perst.StorageError"> StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            record class
            </exception>
        </member>
        <member name="M:Perst.Database.Search(System.String,System.String,System.Int32,System.Int32)">
            <summary> Parse and execute full text search query</summary>
            <param name="query">text of the query
            </param>
            <param name="language">language if the query
            </param>
            <param name="maxResults">maximal amount of selected documents
            </param>
            <param name="timeLimit">limit for query execution time
            </param>
            <returns> result of query execution ordered by rank or null in case of empty or incorrect query
            </returns>
        </member>
        <member name="M:Perst.Database.Search(Perst.FullText.FullTextQuery,System.Int32,System.Int32)">
            <summary> Execute full text search query</summary>
            <param name="query">prepared query
            </param>
            <param name="maxResults">maximal amount of selected documents
            </param>
            <param name="timeLimit">limit for query execution time
            </param>
            <returns> result of query execution ordered by rank or null in case of empty or incorrect query
            </returns>
        </member>
        <member name="M:Perst.Database.UpdateFullTextIndex(System.Object)">
             <summary>
             Update full text index for modified record
             </summary>
             <param name="record">updated record</param>
            
        </member>
        <member name="M:Perst.Database.AddRecord(System.Type,System.Object)">
            <summary>
            Add new record to the specified table. Record is inserted in table corresponding to the specified class.
            Record will be automatically added to all indices existed for this table.
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="record">object to be inserted in the table
            </param>
            <returns> <b>true</b> if record was successfully added to the table, <b>false</b>
            if there is already such record (object with the same ID) in the table
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            record class
            </exception>
        </member>
        <member name="M:Perst.Database.DeleteRecord(System.Object)">
            <summary> 
            Delete record from the table. Record is removed from the table corresponding to the class 
            of the object. Record will be automatically added to all indices existed for this table.
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...
            Object represented the record will be also deleted from the storage.
            </summary>
            <param name="record">object to be deleted from the table
            </param>
            <returns> <b>true</b> if record was successfully deleted from the table, <b>false</b>
            if there is not such record (object with the same ID) in the table
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            record class
            </exception>
        </member>
        <member name="M:Perst.Database.DeleteRecord(System.Type,System.Object)">
            <summary> 
            Delete record from the specified table. Record is removed from the table corresponding to the 
            specified class. Record will be automatically added to all indices existed for this table.
            Object represented the record will be also deleted from the storage.
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="record">object to be deleted from the table
            </param>
            <returns> <b>true</b> if record was successfully deleted from the table, <b>false</b>
            if there is not such record (object with the same ID) in the table
            </returns>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            specified class
            </exception>
        </member>
        <member name="M:Perst.Database.CreateIndex(System.Type,System.String,System.Boolean)">
            <summary>
            Add new index to the table. If such index already exists this method does nothing.
            Since version 2.72 of Perst.Net it is not necessary to create table and index 
            descriptors explicitly: them are automatically create when object is inserted in the 
            database first time (to mark fields for which indices should be created, 
            use Indexable attribute)
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="key">field of the class to be indexed
            </param>
            <param name="unique">if index is unique or not
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if index is created, <b>false</b> if index
            already exists
            </returns>
        </member>
        <member name="M:Perst.Database.CreateIndex(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Add new index to the table. If such index already exists this method does nothing.
            Since version 2.72 of Perst.Net it is not necessary to create table and index 
            descriptors explicitly: them are automatically create when object is inserted in the 
            database first time (to mark fields for which indices should be created, 
            use Indexable attribute)
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="key">field of the class to be indexed
            </param>
            <param name="unique">if index is unique or not
            </param>
            <param name="caseInsensitive">if string index is case insensitive
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if index is created, <b>false</b> if index
            already exists
            </returns>
        </member>
        <member name="M:Perst.Database.DropIndex(System.Type,System.String)">
            <summary>
            Drop index for the specified table and key.
            Does nothing if there is no such index.
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="key">field of the class to be indexed
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if index is deleted, <b>false</b> if index
            is not found
            </returns>
        </member>
        <member name="M:Perst.Database.GetIndex(System.Type,System.String)">
             <summary>
             Get index for the specified field of the class
             </summary>
             <param name="table">class where index is located</param>
             <param name="key">field of the class</param>
             <returns>Index for this field or null if index doesn't exist</returns>
            
        </member>
        <member name="M:Perst.Database.GetIndices(System.Type)">
            <summary>
            Get indices for the specified table
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <returns>hash table of indices
            </returns>
        </member>
        <member name="M:Perst.Database.ExcludeFromIndex(System.Object,System.String)">
            <summary>
            <p>
            Exclude record from specified index. This method is needed to perform update of indexed
            field (key). Before updating the record, it is necessary to exclude it from indices
            which keys are affected. After updating the field, record should be reinserted in these indices
            using includeInIndex method.</p><p>
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...</p><p>
            This method does nothing if there is no index for the specified field.
            </p></summary>
            <param name="record">object to be excluded from the specified index
            </param>
            <param name="key">name of the indexed field
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            record class
            </exception>
            <returns> <b>true</b> if record is excluded from index, <b>false</b> if 
            there is no such index
            </returns>
        </member>
        <member name="M:Perst.Database.ExcludeFromAllIndices(System.Object)">
            <summary>
            <p>
            Exclude record from all indices. This method is needed to perform update of indexed
            field (key). Before updating the record, it is necessary to exclude it from indices
            which keys are affected. After updating the field, record should be reinserted in these indices
            using IncludeInIndex method. If your know which fields will be updated and which indices
            exist for this table, it is more efficient to use ExcludeFromIndex method to exclude
            object only from affected indices.</p><p>
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...</p><p>
            This method does nothing if there is no index for the specified field.
            </p></summary>
            <param name="record">object to be excluded from the specified index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            record class
            </exception>
        </member>
        <member name="M:Perst.Database.ExcludeFromIndex(System.Type,System.Object,System.String)">
            <summary>
            <p>
            Exclude record from specified index. This method is needed to perform update of indexed
            field (key). Before updating the record, it is necessary to exclude it from indices
            which keys are affected. After updating the field, record should be reinserted in these indices
            using includeInIndex method.</p><p>
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...</p><p>
            This method does nothing if there is no index for the specified field.
            </p></summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="record">object to be excluded from the specified index
            </param>
            <param name="key">name of the indexed field
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if record is excluded from index, <b>false</b> if 
            there is no such index
            </returns>
        </member>
        <member name="M:Perst.Database.ExcludeFromAllIndices(System.Type,System.Object)">
            <summary>
            <p>
            Exclude record from all indices. This method is needed to perform update of indexed
            field (key). Before updating the record, it is necessary to exclude it from indices
            which keys are affected. After updating the field, record should be reinserted in these indices
            using IncludeInIndex method. If your know which fields will be updated and which indices
            exist for this table, it is more efficient to use ExcludeFromIndex method to exclude
            object only from affected indices.</p><p>
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...</p><p>
            This method does nothing if there is no index for the specified field.
            </p></summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="record">object to be excluded from the specified index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            record class
            </exception>
        </member>
        <member name="M:Perst.Database.IncludeInIndex(System.Object,System.String)">
            <summary>
            <p>
            Include record in the specified index. This method is needed to perform update of indexed
            field (key). Before updating the record, it is necessary to exclude it from indices
            which keys are affected using excludeFromIndex method. After updating the field, record should be 
            reinserted in these indices using this method.</p><p>
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...</p><p>
            This method does nothing if there is no index for the specified field.
            </p></summary>
            <param name="record">object to be excluded from the specified index
            </param>
            <param name="key">name of the indexed field
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if record is included in index, <b>false</b> if 
            there is no such index or unique constraint is violated
            </returns>
        </member>
        <member name="M:Perst.Database.IncludeInAllIndices(System.Object)">
            <summary>
            <p>
            Include record in all indices. This method is needed to perform update of indexed
            fields (keys). Before updating the record, it is necessary to exclude it from indices
            which keys are affected using excludeFromIndices method. After updating the field, record should be 
            reinserted in these indices using this method. If your know which fields will be updated and which indices
            exist for this table, it is more efficient to use excludeFromIndex/includeInIndex methods to touch
            only affected indices.
            </p></summary>
            <param name="record">object to be excluded from the specified index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if record is included in indices, <b>false</b> if unique unique constraint is violated
            </returns>
        </member>
        <member name="M:Perst.Database.IncludeInIndex(System.Type,System.Object,System.String)">
            <summary>
            <p>
            Include record in the specified index. This method is needed to perform update of indexed
            field (key). Before updating the record, it is necessary to exclude it from indices
            which keys are affected using excludeFromIndex method. After updating the field, record should be 
            reinserted in these indices using this method.</p><p>
            If there is not table associated with class of this object, then 
            database will search for table associated with superclass and so on...</p><p>
            This method does nothing if there is no index for the specified field.
            </p></summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="record">object to be excluded from the specified index
            </param>
            <param name="key">name of the indexed field
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if record is included in index, <b>false</b> if 
            there is no such index or unique constraint is violated
            </returns>
        </member>
        <member name="M:Perst.Database.IncludeInAllIndices(System.Type,System.Object)">
            <summary>
            <p>
            Include record in all indices. This method is needed to perform update of indexed
            fields (keys). Before updating the record, it is necessary to exclude it from indices
            which keys are affected using excludeFromIndices method. After updating the field, record should be 
            reinserted in these indices using this method. If your know which fields will be updated and which indices
            exist for this table, it is more efficient to use excludeFromIndex/includeInIndex methods to touch
            only affected indices.
            </p></summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="record">object to be excluded from the specified index
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <returns> <b>true</b> if record is included in indices, <b>false</b> if unique unique constraint is violated
            </returns>
        </member>
        <member name="M:Perst.Database.UpdateKey(System.Object,System.String,System.Object)">
             <summary>
             This method can be used to update a key field. It is responsibility of programmer in Perst
             to maintain consistency of indices: before updating key field it is necessary to exclude 
             the object from the index and after assigning new value to the key field - reinsert it in the index.
             It can be done using excludeFromIndex/includeInIndex methods, but updateKey combines all this steps:
             exclude from index, update, mark object as been modified and reinsert in index.
             It is safe to call updateKey method for fields which are actually not used in any index - 
             in this case excludeFromIndex/includeInIndex do nothing.
             </summary>
             <param name="record">updated object</param>
             <param name="key">name of the indexed field</param>
             <param name="value">new value of indexed field</param>
             <exception cref="T:Perst.StorageError">StorageError(INDEXED_FIELD_NOT_FOUND) exception is thrown if 
             specified field is not found</exception>
            
        </member>
        <member name="M:Perst.Database.UpdateKey(System.Type,System.Object,System.String,System.Object)">
             <summary>
             This method can be used to update a key field. It is responsibility of programmer in Perst
             to maintain consistency of indices: before updating key field it is necessary to exclude 
             the object from the index and after assigning new value to the key field - reinsert it in the index.
             It can be done using excludeFromIndex/includeInIndex methods, but updateKey combines all this steps:
             exclude from index, update, mark object as been modified and reinsert in index.
             It is safe to call updateKey method for fields which are actually not used in any index - 
             in this case excludeFromIndex/includeInIndex do nothing.
             </summary>
             <param name="record">updated object</param>
             <param name="key">name of the indexed field</param>
             <param name="value">new value of indexed field</param>
             <exception cref="T:Perst.StorageError">StorageError(INDEXED_FIELD_NOT_FOUND) exception is thrown if 
             specified field is not found</exception>
            
        </member>
        <member name="M:Perst.Database.Select(System.Type,System.String)">
            <summary>
            Select record from specified table
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="predicate">search predicate
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <exception cref="T:Perst.CompileError"> exception is thrown if predicate is not valid JSQL exception
            </exception>
            <exception cref="T:Perst.JSQLRuntimeException"> exception is thrown if there is runtime error during query execution
            </exception>
        </member>
        <member name="M:Perst.Database.Select(System.Type,System.String,System.Boolean)">
            <summary>
            Select record from specified table
            </summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="predicate">search predicate
            </param>
            <param name="forUpdate"><b>true</b> if records are selected for update - 
            in this case exclusive lock is set for the table to avoid deadlock.
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <exception cref="T:Perst.CompileError"> exception is thrown if predicate is not valid JSQL exception
            </exception>
            <exception cref="T:Perst.JSQLRuntimeException"> exception is thrown if there is runtime error during query execution
            </exception>
        </member>
        <member name="M:Perst.Database.Prepare(System.Type,System.String)">
            <summary>
            <p>
            Prepare JSQL query. Prepare is needed for queries with parameters. Also
            preparing query can improve speed if query will be executed multiple times
            (using prepare, it is compiled only once).</p><p>
            To execute prepared query, you should use Query.Execute()
            or Query.Execute(db.GetRecords(typeof(XYZ))) method
            </p></summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="predicate">search predicate
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <exception cref="T:Perst.CompileError"> exception is thrown if predicate is not valid JSQL exception
            </exception>
            <returns>prepared query</returns>
        </member>
        <member name="M:Perst.Database.Prepare(System.Type,System.String,System.Boolean)">
            <summary>
            <p>
            Prepare JSQL query. Prepare is needed for queries with parameters. Also
            preparing query can improve speed if query will be executed multiple times
            (using prepare, it is compiled only once).</p><p>
            To execute prepared query, you should use Query.Execute(db.GetRecords(typeof(XYZ))) method
            </p></summary>
            <param name="table">class corresponding to the table
            </param>
            <param name="predicate">search predicate
            </param>
            <param name="forUpdate"><b>true</b> if records are selected for update - 
            in this case exclusive lock is set for the table to avoid deadlock.
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
            <exception cref="T:Perst.CompileError"> exception is thrown if predicate is not valid JSQL exception
            </exception>
            <returns>prepared query</returns>
        </member>
        <member name="M:Perst.Database.CreateQuery(System.Type)">
             <summary>
             Create query for the specified class. You can use Query.getCodeGenerator method to generate 
             query code.
             </summary>
             <param name="table">class corresponding to the table
             </param>
             <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
             the specified class
             </exception>
             <returns>query without predicate</returns>
            
        </member>
        <member name="M:Perst.Database.CreateQuery(System.Type,System.Boolean)">
             <summary>
             Create query for the specified class. You can use Query.getCodeGenerator method to generate 
             query code.
             </summary>
             <param name="table">class corresponding to the table
             </param>
             <param name="forUpdate"><b>true</b> if records are selected for update - 
             in this case exclusive lock is set for the table to avoid deadlock.
             </param>
             <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
             the specified class
             </exception>
             <returns>query without predicate</returns>
            
        </member>
        <member name="M:Perst.Database.GetRecords(System.Type)">
            <summary> 
            Get iterator through all table records
            </summary>
            <param name="table">class corresponding to the table</param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
        </member>
        <member name="M:Perst.Database.GetRecords(System.Type,System.Boolean)">
            <summary> 
            Get iterator through all table records
            </summary>
            <param name="table">class corresponding to the table</param>
            <param name="forUpdate"><b>true</b> if records are selected for update - 
            in this case exclusive lock is set for the table to avoid deadlock.
            </param>
            <exception cref="T:Perst.StorageError">StorageError(CLASS_NOT_FOUND) exception is thrown if there is no table corresponding to 
            the specified class
            </exception>
        </member>
        <member name="P:Perst.Database.EnableAutoIndices">
             <summary>
             Enable or disable automatic creation of indices. 
             If this feature is enabled, Perst will try to create new index each time when it needs it during
             query execution
             </summary>
            
        </member>
        <member name="P:Perst.Database.Storage">
            <summary>
            Get storage associated with this database
            </summary>
            <returns> underlying storage</returns>
        </member>
        <member name="T:Perst.QueryProfiler">
            <summary>    
            Class used to profile query execution. It should be registered as storage listener.
            </summary>
        </member>
        <member name="M:Perst.QueryProfiler.Dump">
            <summary>
            Dump queries execution profile to standard output
            </summary>
        </member>
        <member name="M:Perst.QueryProfiler.Dump(System.IO.TextWriter)">
            <summary>
            Dump queries execution profile to the specified destination
            </summary>
            <param name="out">destination stream where profile should be dumped</param>
        </member>
        <member name="M:Perst.QueryProfiler.GetProfile">
            <summary>
            Get array with QueryInfo elements sorted by (totalTime,count)
            </summary>
        </member>
        <member name="T:Perst.PatriciaTrieKey">
             
             Convert different type of keys to 64-bit long value used in PATRICIA trie 
             (Practical Algorithm To Retrieve Information Coded In Alphanumeric)
            
        </member>
        <member name="F:Perst.PatriciaTrieKey.mask">
            
             Bit mask representing bit vector.
             The last digit of the key is the right most bit of the mask
            
        </member>
        <member name="F:Perst.PatriciaTrieKey.length">
            
             Length of bit vector (can not be larger than 64)
            
        </member>
        <member name="T:Perst.FullText.FullTextSearchResult">
            <summary> Full text search result</summary>
        </member>
        <member name="F:Perst.FullText.FullTextSearchResult.Estimation">
            <summary> Estimation of total number of documents in the index matching this query.
            Full text search query result is usually limited by number of returned documents
            and query execution time. So there are can be more documents in the index matching this query than 
            actually returned. This field provides estimation for total number of documents matching the query.
            </summary>
        </member>
        <member name="F:Perst.FullText.FullTextSearchResult.Hits">
            <summary> Full text search result hits</summary>
        </member>
        <member name="T:Perst.FullText.FullTextSearchHit">
            <summary> Class representing full text search result hit (document + rank)</summary>
        </member>
        <member name="F:Perst.FullText.FullTextSearchHit.Rank">
            <summary> Rank of the document for this query</summary>
        </member>
        <member name="M:Perst.FullText.FullTextSearchHit.#ctor(Perst.Storage,System.Int32,System.Single)">
            <summary> Constructor of the full text search result hit</summary>
        </member>
        <member name="P:Perst.FullText.FullTextSearchHit.Document">
            <summary> Get document matching full text query </summary>
        </member>
        <member name="T:Perst.XMLImportException">
            <summary> Exception thrown during import of data from XML file in database
            </summary>
        </member>
        <member name="T:Perst.StreamFile">
            <summary>
            PERST IFile implementation. Allows to store PERST databases on <see cref="T:System.IO.Stream"/> instances.
            </summary>
        </member>
        <member name="M:Perst.StreamFile.#ctor(System.IO.Stream)">
            <summary>
            Construction
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> where to store the database</param>
        </member>
        <member name="M:Perst.StreamFile.#ctor(System.IO.Stream,System.Int64)">
            <summary>
            Construction
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> where to store the database</param>
            <param name="offset">Offset within the stream where to store/find the database</param>
        </member>
        <member name="M:Perst.StreamFile.Write(System.Int64,System.Byte[])">
            <summary>
            Write method
            </summary>
            <param name="pos">Zero-based position</param>
            <param name="buf">Buffer to write to the stream. The entire buffer is written</param>
        </member>
        <member name="M:Perst.StreamFile.Read(System.Int64,System.Byte[])">
            <summary>
            Read method
            </summary>
            <param name="pos">Zero-based position</param>
            <param name="buf">Buffer where to store <c>buf.Length</c> byte(s) read from the stream</param>
        </member>
        <member name="M:Perst.StreamFile.Sync">
            <summary>
            Flushes the stream (subject to the NoFlush property)
            </summary>
        </member>
        <member name="M:Perst.StreamFile.Close">
            <summary>
            Closes the stream (subject to the NoFlush property)
            </summary>
        </member>
        <member name="M:Perst.StreamFile.Lock(System.Boolean)">
            <summary>
            Locks the stream (no-op)
            </summary>
        </member>
        <member name="P:Perst.StreamFile.NoFlush">
            <summary>
            Boolean property. Set to <c>true</c> to avoid flushing the stream, or <c>false</c> to flush the stream with every calls to <see cref="M:Perst.StreamFile.Sync"/>
            </summary>
        </member>
    </members>
</doc>
